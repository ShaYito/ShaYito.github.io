{"pages":[{"title":"about","text":"A senior undergraduate student fascinated by and dedicated to computer graphics. News I accepted the offer from Clemson University as a PhD in computer graphics with Prof. Yin Yang starting in 2022 fall. --2022.1.25 Interests computer graphics, simulation and physics-based animation, shape reconstrution, physics-based rendering Experiences Research Project: Precise Calibration and Modeling of Piezo-resistive Textile 2020.3-2021.9 Advisor: Prof. Jingyuan Cheng, School of Computer Science and Technology, USTC ◦ Realized a mathematical model to predict the nonlinear behavior of piezoresistive textile ◦ Built a finite-element physical model of the textile Education Bachelor of Engineering in Electronic Science and Technology at University of Science and Technology of China, 2018-2022 Skills ◦ Python (4000 lines, including Taichi) ◦ C++ (3000 lines, including OpenGL) ◦ C# (1200 lines, for Unity) ◦ MATLAB (500 lines) ◦ COMSOL (finite-element simulation, on Structural Mechanics and Electromagnetics) ◦ Cinema 4D (created animations for fun) Contact e-mail: shayito_@outlook.com","link":"/about/"},{"title":"links","text":"Useful Links GAMES (Graphics And Mixed Environment Seminar) Siggraph paper collection Thanks to The author of this hexo theme A great blog framework: hexo","link":"/links/"},{"title":"tags","text":"","link":"/tags/"}],"posts":[{"title":"CUDA10.2+VS2019+win10 configuration","text":"Create a new Empty Project in VS2019, set \"Solution Platforms\" as \"x64\". Right click &lt;Your Project Name&gt;-Build Dependencies-Build Customizations, check CUDA xxxx. (If you cannot find this option, go to C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\extras\\visual_studio_integration\\MSBuildExtensions, copy CUDA 10.2.props to C:\\Program Files (x86)\\MSBuild\\Microsoft.Cpp\\v4.0\\BuildCustomizations replacing the existing CUDA 10.2.props file. See here. Tools-Options-Projects and Solutions-VC++ Project Settings-Extensions To Include: add \".cu\". Right click &lt;Your Project Name&gt;-Properties, make sure Configuration above is always \"All Configurations\" &amp; \"x64\". On this page, go toVC++ Directories in Include Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\include; in Library Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64; go to Linker-General in Additional Library Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64; go to Linker-Input in Additional Dependencies, add files inside directory C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64. in my case, they are cublas.lib;cuda.lib;cudadevrt.lib;cudart.lib;cudart_static.lib;cufft.lib;cufftw.lib;curand.lib;cusolver.lib;cusparse.lib;nppc.lib;nppial.lib;nppicc.lib;nppicom.lib;nppidei.lib;nppif.lib;nppig.lib;nppim.lib;nppist.lib;nppisu.lib;nppitc.lib;npps.lib;nvblas.lib;nvgraph.lib;nvml.lib;nvrtc.lib;OpenCL.lib; Add in Sources Files a file called \"test.cu\", right click it - Properties-General-Item Type: set as \"CUDA C/C++\". Copy the test code below to test.cu, run. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &quot;cuda_runtime.h&quot;#include &quot;device_launch_parameters.h&quot;#include &lt;stdio.h&gt;#include &lt;iostream&gt;int main() { int deviceCount; cudaGetDeviceCount(&amp;deviceCount); printf(&quot;%d device in total\\n&quot;, deviceCount); int dev; for (dev = 0; dev &lt; deviceCount; dev++) { int driver_version(0), runtime_version(0); cudaDeviceProp deviceProp; cudaGetDeviceProperties(&amp;deviceProp, dev); if (dev == 0) if (deviceProp.minor = 9999 &amp;&amp; deviceProp.major == 9999) printf(&quot;\\n&quot;); printf(&quot;Device %d: %s\\n&quot;, dev, deviceProp.name); cudaDriverGetVersion(&amp;driver_version); printf(&quot;CUDA driver version: %d.%d\\n&quot;, driver_version / 1000, (driver_version % 1000) / 10); cudaRuntimeGetVersion(&amp;runtime_version); printf(&quot;CUDA runtime version: %d.%d\\n&quot;, runtime_version / 1000, (runtime_version % 1000) / 10); printf(&quot;device computing capacity: %d.%d\\n&quot;, deviceProp.major, deviceProp.minor); printf(&quot;Total amount of Global Memory: %I64u bytes\\n&quot;, deviceProp.totalGlobalMem); printf(&quot;Number of SMs: %d\\n&quot;, deviceProp.multiProcessorCount); printf(&quot;Total amount of Constant Memory: %I64u bytes\\n&quot;, deviceProp.totalConstMem); printf(&quot;Total amount of Shared Memory per block: %I64u bytes\\n&quot;, deviceProp.sharedMemPerBlock); printf(&quot;Total number of registers available per block: %d\\n&quot;, deviceProp.regsPerBlock); printf(&quot;Warp size: %d\\n&quot;, deviceProp.warpSize); printf(&quot;Max number of threads per SM: %d\\n&quot;, deviceProp.maxThreadsPerMultiProcessor); printf(&quot;Max number of threads per block: %d\\n&quot;, deviceProp.maxThreadsPerBlock); printf(&quot;Max size of each dimension of a block: %d x %d x %d\\n&quot;, deviceProp.maxThreadsDim[0], deviceProp.maxThreadsDim[1], deviceProp.maxThreadsDim[2]); printf(&quot;Max size of each dimension of a grid: %d x %d x %d\\n&quot;, deviceProp.maxGridSize[0], deviceProp.maxGridSize[1], deviceProp.maxGridSize[2]); printf(&quot;Max memory pitch: %I64u bytes\\n&quot;, deviceProp.memPitch); printf(&quot;Max size of texture dimension: 1D=(%d) 2D=(%d x %d) 3D=(%d x %d x %d)\\n&quot;, deviceProp.maxTexture1D, deviceProp.maxTexture2D[0], deviceProp.maxTexture2D[1], deviceProp.maxTexture3D[0], deviceProp.maxTexture3D[1], deviceProp.maxTexture3D[2]); printf(&quot;Max size of layered texture: 1D=(%d) x %d 2D=(%d,%d) x %d\\n&quot;, deviceProp.maxTexture1DLayered[0], deviceProp.maxTexture1DLayered[1], deviceProp.maxTexture2DLayered[0], deviceProp.maxTexture2DLayered[1], deviceProp.maxTexture2DLayered[2]); printf(&quot;Texture alignmemt: %I64u bytes\\n&quot;, deviceProp.texturePitchAlignment); printf(&quot;Clock rate: %.2f GHz\\n&quot;, (double)deviceProp.clockRate * 1.0e-6f); printf(&quot;Memory Clock rate: %.0f MHz\\n&quot;, (double)deviceProp.memoryClockRate * 1.0e-3f); printf(&quot;Memory Bus Width: %d-bit\\n&quot;, deviceProp.memoryBusWidth); printf(&quot;L2 Cache Size: %d bytes\\n&quot;, deviceProp.l2CacheSize); } return 0;}","link":"/2021/12/27/CUDA10-2-VS2019-win10-configuration/"},{"title":"Descent Optimization","text":"Algorithm Initialize ; for do ​ Calculate the descent direction ; ​ Adjust the step length ; ​ ; ​ ; return ; Descent Methods As long as descent direction satisfies , it is a possible descent direction. method descent direction note advantage disadvantage Gradient Descent . can be viewed as updating by force; simple; linear convergence rate; similar to explicit time integration, thus step leangth must be small; Newton's method , is the Hessian matrix of . note: not always descending, unless is positive definite. solve linear equation every iteration; quadratic convergence, the fastest; computationally expensive, not real-time; cannot be easily parallelized on GPU; Quasi-Newton methods approximate the Hessian matrix or its inverse, e.g., BFGS, L-BFGS. it's sequential by nature; less cost per iteration than Newton's; difficult to run on GPU, unless subject to box constraint; Nonlinear Conjugate Gradient(CG) where . generalization of Conjugate Gradient; highely similar to L-BFGS with ; much more friendly with GPU acceleration than quasi-Newton; still require multiple dot product operations, which restrict its performance on the GPU; total cost = per interation cost * number of iterations Reference [1] Parallel Iterative Solvers for Real-time Elastic Deformations - course notes. [2] Huamin Wang's GAMES103 course","link":"/2021/12/23/Descent-Optimization/"},{"title":"IPC","text":"Workflow {\"t\":\"root\",\"d\":0,\"v\":\"\",\"c\":[{\"t\":\"heading\",\"d\":1,\"p\":{\"lines\":[0,1]},\"v\":\"Testa\",\"c\":[{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[2,3]},\"v\":\"test1\"},{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[4,5]},\"v\":\"test2\"}]},{\"t\":\"heading\",\"d\":1,\"p\":{\"lines\":[6,7]},\"v\":\"Testb\",\"c\":[{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[8,9]},\"v\":\"test1\"},{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[10,11]},\"v\":\"test2\"}]}],\"p\":{}} 1 介绍 增量势能接触 (IPC) 求解器是为基于网格离散化的非线性体积弹性动力学问题而构建的，支持大的非线性变形、任意的隐式时间步长、摩擦、任意维数（点、曲线、曲面和体积）的边界、任意的空间离散精度。 The key element：the formulation of contact problem &amp;&amp; the customized numerial method to solve it. 1.1 贡献 一个基于【无符号距离函数(UDF)】的接触模型 barrier几乎处处C2、C1连续 → 可以使用快速收敛的Newton型无约束优化方法(customized Newton-based solver) barrier只影响很少一部分点(≈存在接触的点) → 接触力的施加高度局部化，只有很少一部分barrier需在优化过程中显式计算 contact-aware line search：保证了无穿透(collision-free)，augmented with CCD(由conservative-bound contact specific CFL-inspired filter加速) lagged dissipative potential：一个新的可变的摩擦力模型（带平滑化的静摩擦力） 一个仿真测试集的新benchmark 2 contact model - 接触模型 focus：解”带接触的、非线性volumetric弹性体动力学模型“的数值时间积分问题。 问题等效为：在轨迹上最大化the extended-value action .（？？？） , where are external forces, are dissipative frictional forces. 为简化问题，假设：所有物体都被离散成 n 维的分段线性的element。 我们构建了admissibility的一个新定义，基于无符号距离函数（unsigned distance function, UDF）。最大的好处是可以像处理任意premitives一样的方式，处理任意维度物体之间的碰撞，”处理“ 即 ”构建精确的接触约束（exact contact constraints）“。 （*primitive指point, edge or triangle.） 定义 ”轨迹（trajectories） 为 intersection-free“ ：任意时间t，物体边界上任意两个不同的点p和q之间的距离满足d(p,q)&gt;0。 ，但optimization问题可能在开集上无解。所以我们定义 作为 的闭集。 unsigned distance the set of mesh primitives admissible定义一：a piecewise-linear trajectory starting in an intersection-free state is admissible, if for all times , the configuration satisfies constraints for all , where is the set of all non-adjacent (edge-edge) and non-incident (point-triangle) surface mesh primitive pairs. admissible定义二：A trajectory is admissible, if it is intersection-free, or there is an intersection-free trajectory arbitrarily close. 重要结论：观察到，如果没有intersection，任何primitives之间的距离都以点-三角形、边-边距离为下界。所以It is sufficient to enforce constraints continuously in time, for all , where contains all non-adjacent edge-edge pairs and non-incident point-triangle pairs in surface mesh. Time discretization Incremental Potential (IP) for implicit Euler . 不带约束的最小化问题：牛顿迭代+line search→稳定收敛 . 带约束的最小化问题： 即无穿透. 目标：定义一种数值方法来逼近式(2)的解。 难点：如何s为离散曲面定义无穿透的数学表达式（即的定义），以及如何求解。 对于摩擦接触，引入lagged dissipative potential。 定义：trajectories for which surfaces stay -separated （距离至少） 对接触约束（contact constraints）的处理方案： 增量势（IP）在上不变，则对应的轨迹保留不动； 引入障碍函数，在集合上为0，而在距离趋于零时趋于无穷； 此障碍函数+CCD，保证了轨迹保持在intersection-free的集合中。 2.1 Trajactory Accuracies - 轨迹准确性 因为给能量里引入的新的一项（障碍函数），所以要重新证明以下的性质？还是说接触模拟都需要证明这些性质？ accuracy = admissiblility + discrete momentum balance + positivity + injectivity + complementarity admissiblility：定义见上； discrete momentum balance 离散动量守恒：可以证明IPC自动满足（见Section4.5）；（？） positivity：接触力（contact forces）是推力，而非拉力，即接触力；IPC保证了exact positivity； injectivity：即non-inverting，每一个四面体都保持正的体积；通过使用non-inverting的能量密度函数实现，如Neo-Hookean； complementarity：在接触动力学中，其经典定义是：接触力只能发生在距离为0的表面之间；因为IPC不允许，所以定义一个类似的度量：-complimentarity：. 则 discrete complementarity 定义为，接触的pairs之间的距离小于且当减小时收敛到complementarity。 accuracy记作，单位是速度（见section4.3）。 3 related work computational contact modeling 核心：几何的不相交约束 + 弹性体动量守恒的分辨率（?） 3.1 Constraints and Constraint Proxies - 约束 &amp; 约束代理 因为需要计算admissibility，所以需要选择一种接触约束（contact constraints）的表达形式 不同类型的模型，有不同的表达形 volumetric模型：常用signed distance function (SDF)； mesh模型：选择不一，常成对地定义在相应的表面primitives之间（比如，点-三角形，边-边）； 现有方法 描述 存在问题 利用非线性代理函数及其线性化形式，定义一个局部有向距离。 此类方法包括：线性槽(gap)函数、由几何法向量计算的线性约束、有向体积约束。 这些非线性代理(nonlinear proxies)存在问题：只是局部有效的，因此会引入：artificial ghost contact force (当受剪切力时)、false positives (当旋转时)、discontinuities (当穿越表面元素边界时)。 槽函数法 or “接触点和法向量”法 通过把 一个两两primitives之间的线性化的距离量 局部地映射到 一个固定的几何法向量上，来近似primitives之间的SDF。 迭代的成功率 与 网格表面的变化 敏感（highly varied results; largely dependent on the scene; highly sensitive to surface variations with well-known failure modes） fictitious domain（虚拟域）法 a promising alternatve. 离散化模型的外部空间（air-mesh） 这种全局定义的mesh会导致严重问题，比如shearing &amp; locking forces。 离散SDF（有向距离函数）法 最新的adaptive SDF法（2017），在对固定的mesh采样时，达到了很高的精度的accuracy。 SDF无法快速更新；元素边界上SDF不连续，无法使用光滑的optimization。 3.2 Implicit Time Step Algorithms for Contact - 接触的隐式时间积分算法 选定contact constraint proxy ，要求解的问题是，受约束的IP的最小化问题，即 . 通常的解法是off-the-shelf（Nocedal &amp; Wright, 2006）或customized带约束的优化法。 工程上，常用：SQP（sequential quadratic programming）、augmented Lagrangian，有时用内点法（interior point method）。 存在问题：这些方法都迭代地线性化约束和弹性势能，导致 intersections，特别是在大步长、高速、大形变下； 额外的误差，导致infeasible的子问题、locking、constraint drift； 即使没有以上问题，也无法保证intersection-free，往往依赖于小步长、非物理的防止失败的手段； 3.3 Friction - 摩擦 Maximal Dissipation Principle (MDP) 暂略 3.4 Barrier Functions - 障碍函数 障碍函数在非线性优化中常用，特别是内点法中（Nocedal &amp; Wright, 2006）。其中primal-dual内点法，常加上Lagrangian multipliers作为额外的未知数，来实现更好的收敛。但对于接触问题来说，拉格朗日乘子会扩大系统规模几个数量级，不现实。 所以我们专注于针对接触问题的primal法。大部分文献使用全局支持的函数，但对于接触问题有平方个约束（quadratic set of constraints），所以不可行。 有一些关于【局部支持的障碍函数】（locally supported barriers）的研究，我们顺着这个思路走。 3.5 总结 现在的contact simulation的方法对每一个实例是很有效的，但是基本上都要很费劲地调参才能成功（即得到稳定、不交叉、plausible或可预测的结果）。而且很多调的参数都依赖于大量的数据，而不是基于物理。Towards一个直接的、\"plug and play\"的接触仿真框架，我们提出IPC，对于各种各样的网格分辨率、时间步长、物理条件、材料参数、大形变，我们都确认了IPC不需要条件算法的参数。 4 Primal Barrier Contact Mechanics 4.1 Barrier-augmented Incremental Potential - 带障碍函数的增量势（设计） to enforce for all , we construct a continuous barrier energy (局部的排斥力，只有将要碰撞时才有效) 定义 barrier augmented IP：, with elasticity , adaptive stiffness , barriers . 4.2 Smoothly Clamped Barriers - 平滑截断的障碍函数（设计） 需要clamp的原因：简单地计算energy会导致的复杂度，很多仿真方法只是简单地去掉距离较远的primitives之间的约束（认为它们不会碰撞），这种操作很危险，可能导致不稳定、错过可能的碰撞。我们设计平滑的barrier函数，从而在准确高效地计算所有约束的barrier energy的同时只需考察primitive pairs的一个小子集。 computational distance accuracy target 或 clamping thrshold (= in Section 2) barrier function culled constraint set 4.3 Newton-type Barrier Solver - 牛顿型障碍函数的求解器（使用） projected Newton (PN) ：一种二阶无约束优化策略，用于最小化非线性非凸函数（且Hessian可能indefinite）。 We apply customized PN to barrier-augmented IP. 注意区分：PSD，positive semi-definite，半正定。SPD，symmetric positive definite，对称正定。 每次迭代都把能量的每一项投射为对称半正定（symmetric PSD）矩阵，PSD. ① 把每个元素的elasticity 的Hessian投射到PSD（使用Teran et al. 2005的方法）； ② 把每个barrier 的Hessian也类似地投射到PSD；barrier Hessian 的形式是 所以可以构建成局限于顶点的小矩阵（？？？）； ③ 给总的barrier-augmented IP加上质量矩阵项（mass matrix term），使总能量的Hessian是对称正定（SPD）的。 另：我们也尝试了对以上barrier Hessian使用Gauss-Newton近似，只保留第一个SPD的项，但发现远远不如使用完整的Hessian高效。（？？？） 中止条件：. is time step, not line-search step size, is Newton search direction. 障碍函数stiffness自适应： 两个关键参数 和 ，共同影响有效stiffness；（分辨率参数会影响stiffness算不算缺点？） 若太小，必须要足够近才能施加足够大的力；若太大，距离趋于接近。 两种情况都会导致ill-conditioning和nonsmoothness 4.4 Intersection-aware Line Search (filter)（使用） 灵感来源：inversion-aware line search filter[2] . where our contact forces are given by barrier derivatives 注：barrier趋于无穷不能保证不相交，而是这里的Intersection-aware Line Search保证了IPC的不相交！ 4.5 IPC Solution Update 4.6 Constraint Set Update and CCD Acceleration 6 Distance Computation 6.1 Combinational Distance Computation for pair of primitives （*primitive指point, edge or triangle.） point-triangle distance . edge-edge distance . primitive-primitive diatance two constraints: , where and are and , or two endpoints of edges in edge-edge pair. single constraint: , where ... no constraints: . 这样“无穿透”三个字就可以在任意情况下准确严谨地表达为： . 虽然我们的和其实都可以根据相对位置关系写成连续分段解析函数，我们对“无穿透”三个字的数学描述还是很昂贵的：a 可以取0到1之间无穷个实数，k 的个数则是物体表面点、边、三角形数量的二次方级别的！ 而IPC的解决方案，就是巧用连续碰撞检测(CCD)来对付a，并构造光滑的局部障碍函数来对 k 降维！ anyway 带约束的最小化问题： 即无穿透. 问题转化成无约束的最小化问题 . reference [1] Li - 2020 - IPC. [2] Smith - 2015 - Bijective parameterization with free boundaries. .markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}} const mindmaps = document.querySelectorAll('.markmap-svg'); for(let mindmap of mindmaps) { markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML)); }","link":"/2022/02/08/IPC/"},{"title":"Implicit Geometric Regularization","text":"I looked into the paper 'Implicit Geometric Regularization for Learning Shapes' and did a presentation on it.","link":"/2021/12/11/Implicit-Geometric-Regularization/"},{"title":"Material_Point_Method(MPM)","text":"MPM - Definition a hybrid Lagrangian/Eulerian discretization scheme for solid mechanics (MLS-2018-Hu) the generalization of Particle In Cell (PIC) and Fluid Implicit Particle Method (FLIP) to solid mechanics.(MPM course-2016-Jiang) MPM - Features (MPM course-2016-Jiang) combine Lagrangian material particles (points) with Eulerian Cartesian grids. no inherent need for Lagrangian connectivity. implicitly handle self-collision and fracture with the background Eulerian grid. Continuum Theory (MPM course-2016-Jiang) Continuum assumption can be made for almost all solids and liquids, including deformable (elastic and plastic)objects, muscle, flesh, cloth, hair, liquid, smoke, gas, granular materials (sand, snow, mud, soil, etc.). A continuum body defines quantities such as density, velocity and force as continuous functions of position. The main focus of continuum kinematics/motion is the deformation, either locally or globally in different coordinate systems of interests. Luckily in most cases, we can describe kinematics without introducing the meaning of force, stress or even mass.","link":"/2021/12/06/Material-Point-Method-MPM/"},{"title":"NeRF","text":"NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis NeRF repository contributions neural radiance fields network or ，where only relies on . volume rendering color , where transmittance , ray . radiance field: the color radiating from point in direction . stratified sampling for integral estimation evenly partition into bins, then sample uniformly at random in each bin. color , where , . 注意：采样后变成了（用到了exp(x)-&gt;x+1(x-&gt;0)的近似）；在表达式中，采样值乘区间长度代替了积分。 问题：这里能用Monte-Carol估计积分吗?","link":"/2021/11/30/NeRF/"},{"title":"Numerical Optimization","text":"To catch up with common methods on numerical optimization Condition number 条件数 Condition number of a matrix is the ratio of the largest singular value to the smallest singular value . is also the Lipschitz constant, defined as . is the coefficient of the quadratic term in the quadratic upper bound of a strong convex function. A matrix is ill-conditioned if the condition number is very high, usually indicating that the lowest singular value is orders of magnitude smaller than the highest one, and columns/rows of the matrix are heavily correlated with each other, leading to redundancies and a matrix pretending to be of a higher rank than it truly is. When the Hessian is ill-conditioned, it means the basins of the loss function have contours that are very long \"ellipsoids\" rather than being close to \"circular\". For first-order optimization methods like gradient descent () : need to follow a very zigzag path to the minimum. A typical second-order optimization requires inversion of a Hessian: (First-order optimization methods therefore assume , the identity matrix i.e. the problem is ideally conditioned for gradient descent-like methods.) Inverse of with SVD decomposition is given as . Here is a diagonal matrix with singular values on the diagonal. Note, if the Hessian is ill-conditioned, the inverse can be numerically unstable since the smallest singular values blow up on inversion. A singular value of appears as in . Thus, the more ill-conditioned the Hessian is, the more numerically unstable its inverse. Any noise in computing the Hessian such as that introduced by using stochastic versions of descent updates or using minibatches amplifies tremendously when the Hessian is inverted. Methods like L-BFGS get around this by maintaining a low-rank approximation of the (inverse) Hessian which is better suited for ill-conditioned problems as well as saves computation and space required to implement second-order optimization. Wolfe conditions = sufficient decrease + curvature condition sufficient decrease: . curvature condition: . with . A step length may satisfy the Wolfe conditions without being particularly close to a minimizer of , as we show in Figure 3.5. We can, however, modify the curvature condition to force to lie in at least a broad neighborhood of a local minimizer or stationary point of . strong Wolfe conditions . . with . The only difference is that we no long allow to be too positive. Backtracking 步长从大到小搜索，找到符合sufficient decrease条件的最大步长，免去了curvature条件。 Algorithm 3.1 (Backtracking Line Search). ​ Choose ; ​ Set ; ​ repeat until ​ ; ​ end (repeat) ​ Terminate with . where for some constant Constrained Optimization where Objective function and constraints are all smooth, real-valued functions on a subset of . and are two finite sets of indices. feasible set We can write the problem compactly as two types of optimal conditions: necessary conditions &amp;&amp; sufficient conditions complementarity condition . active set . （等式约束 &amp;&amp; 不等式约束的边界） Augmented Lagrangian Reference [1] Numerial Optimization - 2006 - Nocedal &amp; Wright.","link":"/2022/02/05/Numerical-Optimization/"},{"title":"Projective Dynamics","text":"h Position Based Dynamics (PBD): build a projection for every constraint Projective Dynamics: uses the projection in energy Projective Dynamics 主要思想：通过定义辅助变量，把一个大规模非线性非凸优化问题，拆解成global大规模二次凸优化问题+local多个小规模非线性非凸优化问题，在global和local之间轮番迭代求解。 应用范围：弹簧质点模型[4]、有限元模型[1]、 2016年Narain证明了PD是augmented Lagrangian的一种变形（ADMM: alternating direction method of multipliers） 分类：an implicit integration solver continuum mechanics (physics-based) + PBD 注：连续体力学(continuum mechanics): “弹性体的形变” 由 “弹性势能(elastic potential energy)” 来量化。问题在于：弹性力往往非线性，使运动方程的时间积分变得复杂。 引入连续体动力学的思路：continuous deformation energies -&gt; a specific set of constraints -&gt; potentials: a convex quadratic measure from a constraint -&gt; local/global optimizations use alternating local/global optimization, generalizing efficient implicit time integration of mass-spring system (Liu-2013-Fast simulation of mass-spring system) local step: project every element onto the constraint manifold (用投影法，使每个元素满足约束) global step: 找到各个约束的映射的折中方案，同时考虑全局影响，如惯性和外力。 +Advantages generally, 。 over PBD: physices-based over Newton-based: Newton's needs line search and safeguard against singular or indefinite Hessians to guarantee robustness. Local-Global Iterations PD的精髓：alternating (between local &amp; global) solver 解决的问题：Newton法对非线性非凸函数的优化太慢 以上问题的原因： 每一次迭代都要计算非线性弹性势能函数的Hessian （因为弹性势能依赖于顶点位置）； 因为非凸，所以算出来的Hessian 可能indefinite；（若不正定，Newton法可能给出一个上升的方向，即指想局部极大值点）所以要么选择正定化，要么选择其他方案； Local projection compute the target positions of a subgroup of vertices under the i-th constraint. , . , where is selection matrix for the constraints . and are constant matrice, often Laplacian-like（？）, for a better distance measure. sets the target position of intersecting vertex as it closest projection on the collision plane. nonlinear, but each constraint involves only a few DOFs thus can be parallelized (GPU-friendly). Global solve a standard linear solve for where is the weight of each constraint PD treats collision as a constraint. During simulation, it is refactorized and solved at each L-G ieration as collision constraints vary. reference [1] Bouaziz - 2016 - Projective dynamics: Fusing constraint projections for fast simulation. [2] Intersection-free Deformation on GPU. [3] GAMESWebinar2017-16期(2)-刘天添. [4] Liu - 2013 - Fast Simulation of Mass-Spring Systems. [5] Narain - 2016 - ADMM Projective Dynamics: Fast Simulation of General Constitutive Models","link":"/2022/02/02/Projective-Dynamics/"},{"title":"Volume_Rendering","text":"my Thoughts volume rendering 优点：统一 transparent 和 opaque 物体的渲染方法，如毛发、烟雾等； 缺点：计算量远大于surface rendering；存储量大？ 通过opacity来确认occlusion in NeRF-2020 color , where transmittance , ray . radiance field 指 stratified sampling for integral estimation: do random uniform sample in each even partition . 即 , is the number of partitions. color , where , . 注：采样后换成了，利用； 注：在表达式中，采样值区间长度之积代替了积分。 in Volume Rendering of Neural Implicit Surfaces-2021-Yariv paper page \"In essence, volume rendering is all about approximating the integrated light radiance along this ray reaching the camera.\" \"体渲染的本质：估计积分\" transparency (same as NeRF) opacity , , , and it is monotonic increasing. weight is a PDF (Probability Density Function) color , where is radiance field 注：这里的 相当于NeRF里的 ，只是增加了对边界法向量 的依赖。 \"NeRF is heavily affected by the sampled point during intensity calculation.\" 采样方法的问题： NeRF的 \"random uniform sample\" 会造成 artifacts； 若改成 \"fixed uniform sample\" 会造成另一种 artifacts； in Neural Volumes: Learning Dynamic Renderable Volumes from Images-2019-Lombardi paper page （*本文最早把volume rendering用于novel view synthesis） from Section 6.1 Semi-Transparent Volume Rendering \"If the accumulated opacity reaches 1 (for example, when the ray traverses an opaque region), then no further color can be accumulated on the ray\"","link":"/2021/11/29/Volume-Rendering/"},{"title":"approaches & methods","text":"Descent Methods Gradient Descent: . Newton's method: . Quasi-Newton methods: Nonlinear Conjugate Gradient(CG): , . ADMM: Numerical Procedure Designs Position Based Dynamics (PBD): build a projection for every constraint Projective Dynamics: uses the projection in energy corotational FEM method: can be seen as as projective dynamics with rotation as projection Iterative Linear Solvers Gauss-Seidel: Jacobi: Conjugate gradients: multigrid acceleration methods Chebyshev Semi-Iterative Method: Nesterov's Method:","link":"/2021/12/20/approaches/"},{"title":"cloth simulation","text":"Method 1: Newton's Method + Jacobi Method with Chebyshev Acceleration Newton's method is also called backward Euler or implicit Euler Method 2: Position Based Dynamics + a Jacobi Approach To avoid bias of Gauss-Seidel Approach, we adopt Jacobi Approach. notes on PBD: 'Position based' is relative to 'force based'. PBD updates position first, while force-based methods update velocity first. Update of position is based on projection (a map from to ). See 'A Survey on Position Based Dynamics, 2017' for more detail. See '【深入浅出 Nvidia FleX】(1) Position Based Dynamics' for a concise introduction. Reference [1] Huamin Wang's GAMES103 course","link":"/2021/12/12/cloth-simulation/"},{"title":"elastic simulation","text":"Deformation undeformed/reference configuration deformed configuration deformation map deformation gradiant or ( is the Jacobian matrix of ) Strain &amp; Hyperelasticity strain energy note: for hyperelastic materials, only depends on (or the initial and final configurations and ) and not on the deformation path over time (or equivalently, the elastic forces of hyperelastic materials are conservative). energy density measures the strain energy per unit undeformed volume on an infinitesiml domain around the mateiral point using first-order Taylor expansion thus, is a function of alone, i.e. . Force &amp; Traction force density aggragate force on a finite region is . traction (surface force density) aggragate force on a finite boundary region is . Stress 1st Piola-Kirchhoff stress (a 3*3 matrix or tensor, short as PK1 stress) where is outward normalunit normal to the boundary in the undeformed configuration. or for hyperelastic materials, note Much literature define and because and are seen as external. However, such definitions are only true when the body is in an equilibrium configuration. We retain our original definition above and denote external force and traction as and . Strain Green strain (tensor) if we do polar decomposition deformation gradient as , then small/infinitesimal strain (tensor, a linear approximation of ) 🐇 Linear Elasticity . where . . 🐇 Neo-Hookean Elasticity . where (the same as linear elasticity), is dimension. . the most often used elasticity model in CG. 🐇 St. Venant-Kirchhoff Elasticity Replacing strain in Linear Elasticity with , we get . . in energy density , is against stretch, is against volume change. rotational invariant, but with quartic complexity. Elasticity Modeling Procedures Given , for each tetrahedron (the simplest finite element in 3D, often used in CG), pre-compute (the volume) and (the inverse of the reference edge matrix). Update by Newton's (, ) to get , then calculate . Now we can get gradient , stress (according to its formula in each elasticity model). Finally, calculate force and Update by Newton's. 🐇 Corotated Linear Elasticity Replacing strain in Linear Elasticity with (by polar decomposition ), we get where is from singular value decomposition (SVD) . rotational invariant, but the polar decomposition is computationally costly. Rotationally Invariant &amp; Isotropic rotationally invariant: if and only if . isotropic: if and only if . Using SVD , we conclude that rotationally invariant and isotropic materials satisfy . Invariants right Cauchy Green tensor . Using SVD , with . . invariants . . . reference [1] SIGGRAPH 2012 Course \"FEM Simulation of 3D Deformable Solids: A practitioner's guide to theory, discretization and model reduction\"","link":"/2021/12/15/elastic-simulation/"},{"title":"linear solver","text":"Problem Solvers Iterators Gauss-Seidel iteration Jacobi Jacobi v.s. Gauss-Seidel [2] Conjugate gradients Reference [1] Huamin Wang's GAMES103 course and Yuanming Hu's GAMES201 course [2] Bouaziz - 2016 - Projective dynamics: Fusing constraint projections for fast simulation.","link":"/2021/12/13/linear-solver/"},{"title":"collision simulation","text":"Collision Detection Pipeline Broad-Phase Collision Culling Spatial Hashing (SH) Easy to implement GPU friendly Needs to recompute after updating objects Bounding Volume Hierarchy (BVH) More involved Not GPU friendly To update BVH, just update bounding volumes Pairs edge-triangle pair, or vertex-triangle and edge-edge pairs Narrow-Phase Collision Test Discrete Collision Detect (DCD) issues with DCD Continuous Collision Detect (CCD) issues with CCD Floating-point errors, especially due to root finding of a cubic equation Buffering epsilons, but that causes false positives. Gaming GPUs often use single floating-point precision. Computational costs: more expensive than DCD. Some argue that broad-phase collision culling is the bottleneck. Difficulty in implementation. Collision Response Two methods: Interior Point Method &amp;&amp; Impact Zone Optimization. Interior Point Method Log-Barrier implementation Impact Zone Optimization We can also turning this into an unconstraint optimization problem: Augmented Lagrangian pros &amp; cons Reference [1] Huamin Wang's GAMES103 course, 09_collision [2] Incremental Potential Contact-2020-Li","link":"/2022/01/05/collision-simulation/"},{"title":"multigrid","text":"A standalone multigrid method can be seen as a type of iterative methods to solve for linear systems.[1] Model Problem One-dimensional boundary value problem . . grid . 设和，. Approximate using Taylor series, we get . The problem turns into . . Let 和. 矩阵形式，其中是N-1阶对称正定矩阵， . 解法： Direct 高斯消元（Gaussian elimination） 因式分解（Factorization） Iterative Jacobi Gauss-Seidel Conjugate Gradient Iterative Methods for Linear Systems Consider and let be an approximation to . error , with norms , . residual , with norms , . residual equation . residual correction . Relaxation Schemes Consider the 1D model problem . Jacobi Relaxation . Let where is diagonal and and are the strictly lower and upper parts of . Then becomes Let , subtracting from , we get . Weighted Jacobi Relaxation . . Gauss-Seidel Relaxation . , as well, then . Let Red-Black Gauss-Seidel Relaxation even (red) points: . odd (black) points: . note: Jacobi and Red-Black Gauss-Seidel are both suitable for parallel computation. Analysis of stationary iterations Let . The exact solution is unchanged by the iteration, i.e., . . . Fundamentals of Fourier Fourier modes , component , mode/frequency . Fundamentals of iteration spectral radius . is convergent ( as ) if and only if . asymptotic(渐近线的) convegence rate . *note: the number of iterations needed to reduce the error by : . Convergence of Jacobi &amp; weighted Jacobi on Au=0 relaxation matrix , eigenvalues . (let ) , where . ∴ . and have the same eigenvectors , with its component , , . meaning of eigenvalues Expand the initial error with eigenvectors: After iterations, . The mode of the error is reduced by at each iteration. choice of weight Note that if then for （即所有频率都会衰减） 但long waves()在任何下都几乎不衰减，如. Choose a that best dump the short waves(): let . smoothing factor smoothing factor . (compare with spectral radius ) For , with , . experiment Jacobi method on with . Number of iterations required to reduce to . Initial guess: . Important conclusion(*) Many relaxation shemes have the smoothing property, where oscillatory modes of the error are eliminated effectively, but smooth modes are damped very slowly. or say, Relaxation is most effective on oscillatory error modes. Convergence of Gauss-Seidel on Au=0 . . . and have different eigenvectors, Gauss-Seidel mixes the modes of . Multigrid fine grid(fg) or : separated into with grid length . coarse grid(cg) or : separated into with grid length . two ideas 1) Nested Iteration use cg compute an improved initial guess for fg relxation. Relaxation on cg is much cheaper (1/2 in 1D, 1/4 in 2D, 1/8 in 3D). Relaxation on cg has a marginally better convergence rate, e.g. instead of . procedures: ... Relax on on to obtain intial guess . Relax on on to obtain intial guess . Relax on on to obtain the final solution. But, what is on , , ...? What if the error still has smooth components when we get to the fine grid ? 2) Coarse-Grid Correction use error relaxed on cg to correct the approximation . Smooth error is more oscillatory in cg, thus relaxation is more effective. (See conclusion(*)). Use the residual equation to relax on the error . But, what does it mean to relax on on ? How to relax on and what initial guess should be used? How do we transfer the error estimate from back to ? explorations on the ideas Intergrid transfer operators For , the mode is preserved on cg. (the superscript indicates the grids on which the vectors are defined). For , the mode on fg becomes mode on cg. (called aliasing) . Prolongation operator Considering the 1D case, , where , for . We may regard as a linear operator from to . e.g. for , has full rank, and thus null space is empty set （即无解）. If is smooth, approximate very well. If is oscillatory, approximate not well. Therefore, Nested Iteration is most effective when the error is smooth. Restriction operator Considering the 1D case, restriction by injection: , where . restriction by full-weighting: , where . In the discussion that follows, we use full weighting as a restriction operator. We may regard as a linear operator from to . e.g. for , has rank , and thus . Relation between prolongation and restriction A commonly used and highly useful requirement is , for in . The fact that the interpolation operator and the full weighting operator are transposes of each other up to a constant is called a variational property and will soon be of importance. Two-Grid Correction Scheme（解） . Relax times on on with initial guess . Compute residual: . Restrict (transfer to cg): . Solve on with initial guess .（直接法求解，或嵌套Two-Grid Correction变成-Cycle） Prolongate/Interpolate (transfer to fg): . Correct the approximation . Relax times on on with intial guess . What is ? Galerkin condition (dirived in Chapter 5) variational properties = Galerkin condition + symmetric property. symmetric property: . How to solve the cg residual equation? Recursion! Schemes for solving residual equation（解 ） We use to denote approximations to . -Cycle Scheme（相当于对使用Two-Grid Correction Scheme） . Relax times on with a given initial guess . If , then go to step 4. Else , -- , -- initial guess . Correct . Relax times on with initial guess . The -cycle is just one of a family of multigrid cycling schemes. The entire family is called the -cycle method and is defined recursively by the following. -Cycle Scheme . Relax times on with a given initial guess . If , then go to step 4. Else , , times. Correct . Relax times on with initial guess . In practice, only (-cycle) and (-cycle) are used. ideas combined The algorithm that joins nested iteration with the V-cycle is called the full multigrid -cycle (FMG). Full Multigrid V-Cycle (Recursive Form) . If , set and go to step 3. Else , ​ . Correct . times. Below shows the schedule of grids for FMG with . 问题： 如何定义multigrid的每一层grid； multigrid法是静态迭代法（stationary iterative method，比如Gauss-Seidel、Jacobi）吗 Reference [1] A Scalable Galerkin Method-2019-Xian et al. [2] A Multigrid Tutorial, 2nd Edition-2000-Briggs et al.","link":"/2022/01/13/multigrid/"},{"title":"my FEM elastic simulation with Unity","text":"I finished Huamin Wang's GAMES103 homework 3. results: St. Venant Kirchhoff Model: Neo-Hookean Model + SVD (the 'principal stretches' or 'matrix invariants' method) A late Merry Christmas to myself ! ❄🎄🎅🔥😊 2021.12.26","link":"/2021/12/26/my-FEM-elastic-simulation-with-Unity/"},{"title":"rigid body collision","text":"Method: Shape Matching Basic Idea: first handle collision and friction of vertices independetnly, then enforce constraint to restore regidity. Advantages: Easy to implement and compatible with other nodal systems, i.e., cloth and soft bodies. Disadvantages: Difficult to strictly enforce friction and other goals. (The rigidification process will destroy them.) Suggestion: More suitable when the friction accuracy is less important, i.e., buttons on clothes. Reference Huamin Wang's GAMES103 course","link":"/2021/12/11/rigid-body-collision/"},{"title":"time integration","text":"integrators forward Euler (explicit Euler): semi-implicit Euler (symplectic) backward Euler (implicit Euler) or Newton's method: (see one of the applications of this method here) comparison: explict vs. implict explict (forward Euler, symplectic Euler, RK, ... ) easy to implement, future only relies on past. 😟easy to explode: , especially for stiff materials. implicit (backward Euler, middle-point, ... ) future relies on past &amp; future, need to solve equations. support larger time step (robustness, thus the mainstream) 😟numerical damping &amp; locking. unifying CFL condition , where is CFL number, is time step, is length interval (e.g. particle radius, grid size), is maximum (velocity) Typical : SPH: MPM: FLIP fluid (smoke): reference [1] Yuanming Hu - ppt in the course GAMES201. [2] Bouaziz - 2016 - Projective dynamics: Fusing constraint projections for fast simulation.","link":"/2021/12/13/time-integration/"}],"tags":[{"name":"tutorial","slug":"tutorial","link":"/tags/tutorial/"},{"name":"Newton","slug":"Newton","link":"/tags/Newton/"},{"name":"gradient","slug":"gradient","link":"/tags/gradient/"},{"name":"iterative","slug":"iterative","link":"/tags/iterative/"},{"name":"paper","slug":"paper","link":"/tags/paper/"},{"name":"2020","slug":"2020","link":"/tags/2020/"},{"name":"siggraph","slug":"siggraph","link":"/tags/siggraph/"},{"name":"presentation","slug":"presentation","link":"/tags/presentation/"},{"name":"elastic","slug":"elastic","link":"/tags/elastic/"},{"name":"simulation","slug":"simulation","link":"/tags/simulation/"},{"name":"method","slug":"method","link":"/tags/method/"},{"name":"mpm","slug":"mpm","link":"/tags/mpm/"},{"name":"ECCV","slug":"ECCV","link":"/tags/ECCV/"},{"name":"optimization","slug":"optimization","link":"/tags/optimization/"},{"name":"Lagrangian","slug":"Lagrangian","link":"/tags/Lagrangian/"},{"name":"Projective Dynamics","slug":"Projective-Dynamics","link":"/tags/Projective-Dynamics/"},{"name":"rendering","slug":"rendering","link":"/tags/rendering/"},{"name":"neural","slug":"neural","link":"/tags/neural/"},{"name":"sum-up","slug":"sum-up","link":"/tags/sum-up/"},{"name":"cloth","slug":"cloth","link":"/tags/cloth/"},{"name":"PBD","slug":"PBD","link":"/tags/PBD/"},{"name":"Jacobi","slug":"Jacobi","link":"/tags/Jacobi/"},{"name":"Chebyshev","slug":"Chebyshev","link":"/tags/Chebyshev/"},{"name":"Gauss-Seidel","slug":"Gauss-Seidel","link":"/tags/Gauss-Seidel/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"collision","slug":"collision","link":"/tags/collision/"},{"name":"CCD","slug":"CCD","link":"/tags/CCD/"},{"name":"DCD","slug":"DCD","link":"/tags/DCD/"},{"name":"BVH","slug":"BVH","link":"/tags/BVH/"},{"name":"SH","slug":"SH","link":"/tags/SH/"},{"name":"Interior Point Method","slug":"Interior-Point-Method","link":"/tags/Interior-Point-Method/"},{"name":"Impact Zone Optimization","slug":"Impact-Zone-Optimization","link":"/tags/Impact-Zone-Optimization/"},{"name":"rigid","slug":"rigid","link":"/tags/rigid/"},{"name":"implicit","slug":"implicit","link":"/tags/implicit/"}],"categories":[]}