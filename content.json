{"pages":[{"title":"about","text":"A senior undergraduate student fascinated by and dedicated to computer graphics. NewsI accepted the offer from Clemson University as a PhD in computer graphics with Prof. Yin Yang starting in 2022 fall. â€”2022.1.25 Interestscomputer graphics, simulation and physics-based animation, shape reconstrution, physics-based rendering ExperiencesResearch Project: Precise Calibration and Modeling of Piezo-resistive Textile 2020.3-2021.9 Advisor: Prof. Jingyuan Cheng, School of Computer Science and Technology, USTC â—¦ Realized a mathematical model to predict the nonlinear behavior of piezoresistive textile â—¦ Built a finite-element physical model of the textile EducationBachelor of Engineering in Electronic Science and Technology at University of Science and Technology of China, 2018-2022 Skillsâ—¦ Python (4000 lines, including Taichi) â—¦ C++ (3000 lines, including OpenGL) â—¦ C# (1200 lines, for Unity) â—¦ MATLAB (500 lines) â—¦ COMSOL (finite-element simulation, on Structural Mechanics and Electromagnetics) â—¦ Cinema 4D (created animations for fun) Contacte-mail: shayito_@outlook.com","link":"/about/"},{"title":"links","text":"Useful Links GAMES (Graphics And Mixed Environment Seminar) Siggraph paper collection Thanks to The author of this hexo theme A great blog framework: hexo","link":"/links/"},{"title":"tags","text":"","link":"/tags/"}],"posts":[{"title":"Descent Optimization","text":"Algorithm Initialize ; for do â€‹ Calculate the descent direction ; â€‹ Adjust the step length ; â€‹ ; â€‹ ; return ; Descent Methods As long as descent direction satisfies , it is a possible descent direction. method descent direction note advantage disadvantage Gradient Descent . can be viewed as updating by force; simple; linear convergence rate; similar to explicit time integration, thus step leangth must be small; Newton's method , is the Hessian matrix of . note: not always descending, unless is positive definite. solve linear equation every iteration; quadratic convergence, the fastest; computationally expensive, not real-time; cannot be easily parallelized on GPU; Quasi-Newton methods approximate the Hessian matrix or its inverse, e.g., BFGS, L-BFGS. it's sequential by nature; less cost per iteration than Newton's; difficult to run on GPU, unless subject to box constraint; Nonlinear Conjugate Gradient(CG) where . generalization of Conjugate Gradient; highely similar to L-BFGS with ; much more friendly with GPU acceleration than quasi-Newton; still require multiple dot product operations, which restrict its performance on the GPU; total cost = per interation cost * number of iterations Reference [1] Parallel Iterative Solvers for Real-time Elastic Deformations - course notes. [2] Huamin Wang's GAMES103 course","link":"/2021/12/23/Descent-Optimization/"},{"title":"CUDA10.2+VS2019+win10 configuration","text":"Create a new Empty Project in VS2019, set \"Solution Platforms\" as \"x64\". Right click &lt;Your Project Name&gt;-Build Dependencies-Build Customizations, check CUDA xxxx. (If you cannot find this option, go to C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\extras\\visual_studio_integration\\MSBuildExtensions, copy CUDA 10.2.props to C:\\Program Files (x86)\\MSBuild\\Microsoft.Cpp\\v4.0\\BuildCustomizations replacing the existing CUDA 10.2.props file. See here. Tools-Options-Projects and Solutions-VC++ Project Settings-Extensions To Include: add \".cu\". Right click &lt;Your Project Name&gt;-Properties, make sure Configuration above is always \"All Configurations\" &amp; \"x64\". On this page, go toVC++ Directories in Include Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\include; in Library Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64; go to Linker-General in Additional Library Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64; go to Linker-Input in Additional Dependencies, add files inside directory C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64. in my case, they are cublas.lib;cuda.lib;cudadevrt.lib;cudart.lib;cudart_static.lib;cufft.lib;cufftw.lib;curand.lib;cusolver.lib;cusparse.lib;nppc.lib;nppial.lib;nppicc.lib;nppicom.lib;nppidei.lib;nppif.lib;nppig.lib;nppim.lib;nppist.lib;nppisu.lib;nppitc.lib;npps.lib;nvblas.lib;nvgraph.lib;nvml.lib;nvrtc.lib;OpenCL.lib; Add in Sources Files a file called \"test.cu\", right click it - Properties-General-Item Type: set as \"CUDA C/C++\". Copy the test code below to test.cu, run. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &quot;cuda_runtime.h&quot;#include &quot;device_launch_parameters.h&quot;#include &lt;stdio.h&gt;#include &lt;iostream&gt;int main() { int deviceCount; cudaGetDeviceCount(&amp;deviceCount); printf(&quot;%d device in total\\n&quot;, deviceCount); int dev; for (dev = 0; dev &lt; deviceCount; dev++) { int driver_version(0), runtime_version(0); cudaDeviceProp deviceProp; cudaGetDeviceProperties(&amp;deviceProp, dev); if (dev == 0) if (deviceProp.minor = 9999 &amp;&amp; deviceProp.major == 9999) printf(&quot;\\n&quot;); printf(&quot;Device %d: %s\\n&quot;, dev, deviceProp.name); cudaDriverGetVersion(&amp;driver_version); printf(&quot;CUDA driver version: %d.%d\\n&quot;, driver_version / 1000, (driver_version % 1000) / 10); cudaRuntimeGetVersion(&amp;runtime_version); printf(&quot;CUDA runtime version: %d.%d\\n&quot;, runtime_version / 1000, (runtime_version % 1000) / 10); printf(&quot;device computing capacity: %d.%d\\n&quot;, deviceProp.major, deviceProp.minor); printf(&quot;Total amount of Global Memory: %I64u bytes\\n&quot;, deviceProp.totalGlobalMem); printf(&quot;Number of SMs: %d\\n&quot;, deviceProp.multiProcessorCount); printf(&quot;Total amount of Constant Memory: %I64u bytes\\n&quot;, deviceProp.totalConstMem); printf(&quot;Total amount of Shared Memory per block: %I64u bytes\\n&quot;, deviceProp.sharedMemPerBlock); printf(&quot;Total number of registers available per block: %d\\n&quot;, deviceProp.regsPerBlock); printf(&quot;Warp size: %d\\n&quot;, deviceProp.warpSize); printf(&quot;Max number of threads per SM: %d\\n&quot;, deviceProp.maxThreadsPerMultiProcessor); printf(&quot;Max number of threads per block: %d\\n&quot;, deviceProp.maxThreadsPerBlock); printf(&quot;Max size of each dimension of a block: %d x %d x %d\\n&quot;, deviceProp.maxThreadsDim[0], deviceProp.maxThreadsDim[1], deviceProp.maxThreadsDim[2]); printf(&quot;Max size of each dimension of a grid: %d x %d x %d\\n&quot;, deviceProp.maxGridSize[0], deviceProp.maxGridSize[1], deviceProp.maxGridSize[2]); printf(&quot;Max memory pitch: %I64u bytes\\n&quot;, deviceProp.memPitch); printf(&quot;Max size of texture dimension: 1D=(%d) 2D=(%d x %d) 3D=(%d x %d x %d)\\n&quot;, deviceProp.maxTexture1D, deviceProp.maxTexture2D[0], deviceProp.maxTexture2D[1], deviceProp.maxTexture3D[0], deviceProp.maxTexture3D[1], deviceProp.maxTexture3D[2]); printf(&quot;Max size of layered texture: 1D=(%d) x %d 2D=(%d,%d) x %d\\n&quot;, deviceProp.maxTexture1DLayered[0], deviceProp.maxTexture1DLayered[1], deviceProp.maxTexture2DLayered[0], deviceProp.maxTexture2DLayered[1], deviceProp.maxTexture2DLayered[2]); printf(&quot;Texture alignmemt: %I64u bytes\\n&quot;, deviceProp.texturePitchAlignment); printf(&quot;Clock rate: %.2f GHz\\n&quot;, (double)deviceProp.clockRate * 1.0e-6f); printf(&quot;Memory Clock rate: %.0f MHz\\n&quot;, (double)deviceProp.memoryClockRate * 1.0e-3f); printf(&quot;Memory Bus Width: %d-bit\\n&quot;, deviceProp.memoryBusWidth); printf(&quot;L2 Cache Size: %d bytes\\n&quot;, deviceProp.l2CacheSize); } return 0;}","link":"/2021/12/27/CUDA10-2-VS2019-win10-configuration/"},{"title":"IPC","text":"Workflow {\"t\":\"root\",\"d\":0,\"v\":\"\",\"c\":[{\"t\":\"heading\",\"d\":1,\"p\":{\"lines\":[0,1]},\"v\":\"Testa\",\"c\":[{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[2,3]},\"v\":\"test1\"},{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[4,5]},\"v\":\"test2\"}]},{\"t\":\"heading\",\"d\":1,\"p\":{\"lines\":[6,7]},\"v\":\"Testb\",\"c\":[{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[8,9]},\"v\":\"test1\"},{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[10,11]},\"v\":\"test2\"}]}],\"p\":{}} 1 ä»‹ç»å¢é‡åŠ¿èƒ½æ¥è§¦ (IPC) æ±‚è§£å™¨æ˜¯ä¸ºåŸºäºç½‘æ ¼ç¦»æ•£åŒ–çš„éçº¿æ€§ä½“ç§¯å¼¹æ€§åŠ¨åŠ›å­¦é—®é¢˜è€Œæ„å»ºçš„ï¼Œæ”¯æŒå¤§çš„éçº¿æ€§å˜å½¢ã€ä»»æ„çš„éšå¼æ—¶é—´æ­¥é•¿ã€æ‘©æ“¦ã€ä»»æ„ç»´æ•°ï¼ˆç‚¹ã€æ›²çº¿ã€æ›²é¢å’Œä½“ç§¯ï¼‰çš„è¾¹ç•Œã€ä»»æ„çš„ç©ºé—´ç¦»æ•£ç²¾åº¦ã€‚ The key elementï¼šthe formulation of contact problem &amp;&amp; the customized numerial method to solve it. 1.1 è´¡çŒ® ä¸€ä¸ªåŸºäºã€æ— ç¬¦å·è·ç¦»å‡½æ•°(UDF)ã€‘çš„æ¥è§¦æ¨¡å‹ barrierå‡ ä¹å¤„å¤„C2ã€C1è¿ç»­ â†’ å¯ä»¥ä½¿ç”¨å¿«é€Ÿæ”¶æ•›çš„Newtonå‹æ— çº¦æŸä¼˜åŒ–æ–¹æ³•(customized Newton-based solver) barrieråªå½±å“å¾ˆå°‘ä¸€éƒ¨åˆ†ç‚¹(â‰ˆå­˜åœ¨æ¥è§¦çš„ç‚¹) â†’ æ¥è§¦åŠ›çš„æ–½åŠ é«˜åº¦å±€éƒ¨åŒ–ï¼Œåªæœ‰å¾ˆå°‘ä¸€éƒ¨åˆ†barrieréœ€åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­æ˜¾å¼è®¡ç®— contact-aware line searchï¼šä¿è¯äº†æ— ç©¿é€(collision-free)ï¼Œaugmented with CCD(ç”±conservative-bound contact specific CFL-inspired filteråŠ é€Ÿ) lagged dissipative potentialï¼šä¸€ä¸ªæ–°çš„å¯å˜çš„æ‘©æ“¦åŠ›æ¨¡å‹ï¼ˆå¸¦å¹³æ»‘åŒ–çš„é™æ‘©æ“¦åŠ›ï¼‰ ä¸€ä¸ªä»¿çœŸæµ‹è¯•é›†çš„æ–°benchmark 2 contact model - æ¥è§¦æ¨¡å‹focusï¼šè§£â€å¸¦æ¥è§¦çš„ã€éçº¿æ€§volumetricå¼¹æ€§ä½“åŠ¨åŠ›å­¦æ¨¡å‹â€œçš„æ•°å€¼æ—¶é—´ç§¯åˆ†é—®é¢˜ã€‚ é—®é¢˜ç­‰æ•ˆä¸ºï¼šåœ¨è½¨è¿¹ä¸Šæœ€å¤§åŒ–the extended-value action .ï¼ˆï¼Ÿï¼Ÿï¼Ÿï¼‰ , where are external forces, are dissipative frictional forces. ä¸ºç®€åŒ–é—®é¢˜ï¼Œå‡è®¾ï¼šæ‰€æœ‰ç‰©ä½“éƒ½è¢«ç¦»æ•£æˆ n ç»´çš„åˆ†æ®µçº¿æ€§çš„elementã€‚ æˆ‘ä»¬æ„å»ºäº†admissibilityçš„ä¸€ä¸ªæ–°å®šä¹‰ï¼ŒåŸºäºæ— ç¬¦å·è·ç¦»å‡½æ•°ï¼ˆunsigned distance function, UDFï¼‰ã€‚æœ€å¤§çš„å¥½å¤„æ˜¯å¯ä»¥åƒå¤„ç†ä»»æ„premitivesä¸€æ ·çš„æ–¹å¼ï¼Œå¤„ç†ä»»æ„ç»´åº¦ç‰©ä½“ä¹‹é—´çš„ç¢°æ’ï¼Œâ€å¤„ç†â€œ å³ â€æ„å»ºç²¾ç¡®çš„æ¥è§¦çº¦æŸï¼ˆexact contact constraintsï¼‰â€œã€‚ ï¼ˆ*primitiveæŒ‡point, edge or triangle.ï¼‰ å®šä¹‰ â€è½¨è¿¹ï¼ˆtrajectoriesï¼‰ ä¸º intersection-freeâ€œ ï¼šä»»æ„æ—¶é—´tï¼Œç‰©ä½“è¾¹ç•Œä¸Šä»»æ„ä¸¤ä¸ªä¸åŒçš„ç‚¹på’Œqä¹‹é—´çš„è·ç¦»æ»¡è¶³d(p,q)&gt;0ã€‚ ï¼Œä½†optimizationé—®é¢˜å¯èƒ½åœ¨å¼€é›†ä¸Šæ— è§£ã€‚æ‰€ä»¥æˆ‘ä»¬å®šä¹‰ ä½œä¸º çš„é—­é›†ã€‚ unsigned distance the set of mesh primitives admissibleå®šä¹‰ä¸€ï¼ša piecewise-linear trajectory starting in an intersection-free state is admissible, if for all times , the configuration satisfies constraints for all , where is the set of all non-adjacent (edge-edge) and non-incident (point-triangle) surface mesh primitive pairs. admissibleå®šä¹‰äºŒï¼šA trajectory is admissible, if it is intersection-free, or there is an intersection-free trajectory arbitrarily close. é‡è¦ç»“è®ºï¼šè§‚å¯Ÿåˆ°ï¼Œå¦‚æœæ²¡æœ‰intersectionï¼Œä»»ä½•primitivesä¹‹é—´çš„è·ç¦»éƒ½ä»¥ç‚¹-ä¸‰è§’å½¢ã€è¾¹-è¾¹è·ç¦»ä¸ºä¸‹ç•Œã€‚æ‰€ä»¥It is sufficient to enforce constraints continuously in time, for all , where contains all non-adjacent edge-edge pairs and non-incident point-triangle pairs in surface mesh. Time discretizationIncremental Potential (IP) for implicit Euler . ä¸å¸¦çº¦æŸçš„æœ€å°åŒ–é—®é¢˜ï¼šç‰›é¡¿è¿­ä»£+line searchâ†’ç¨³å®šæ”¶æ•› . å¸¦çº¦æŸçš„æœ€å°åŒ–é—®é¢˜ï¼š å³æ— ç©¿é€. ç›®æ ‡ï¼šå®šä¹‰ä¸€ç§æ•°å€¼æ–¹æ³•æ¥é€¼è¿‘å¼(2)çš„è§£ã€‚ éš¾ç‚¹ï¼šå¦‚ä½•sä¸ºç¦»æ•£æ›²é¢å®šä¹‰æ— ç©¿é€çš„æ•°å­¦è¡¨è¾¾å¼ï¼ˆå³çš„å®šä¹‰ï¼‰ï¼Œä»¥åŠå¦‚ä½•æ±‚è§£ã€‚ å¯¹äºæ‘©æ“¦æ¥è§¦ï¼Œå¼•å…¥lagged dissipative potentialã€‚ 2.1 Trajactory Accuracies - è½¨è¿¹å‡†ç¡®æ€§å®šä¹‰ï¼štrajectories for which surfaces stay -separated ï¼ˆè·ç¦»è‡³å°‘ï¼‰ 3 related workcomputational contact modeling æ ¸å¿ƒï¼šå‡ ä½•çš„ä¸ç›¸äº¤çº¦æŸ + å¼¹æ€§ä½“åŠ¨é‡å®ˆæ’çš„åˆ†è¾¨ç‡ï¼ˆ?ï¼‰ 3.1 Constraints and Constraint Proxies - çº¦æŸ &amp; çº¦æŸä»£ç†å› ä¸ºéœ€è¦è®¡ç®—admissibilityï¼Œæ‰€ä»¥éœ€è¦é€‰æ‹©ä¸€ç§æ¥è§¦çº¦æŸï¼ˆcontact constraintsï¼‰çš„è¡¨è¾¾å½¢å¼ ä¸åŒç±»å‹çš„æ¨¡å‹ï¼Œæœ‰ä¸åŒçš„è¡¨è¾¾å½¢ volumetricæ¨¡å‹ï¼šå¸¸ç”¨signed distance function (SDF)ï¼› meshæ¨¡å‹ï¼šé€‰æ‹©ä¸ä¸€ï¼Œå¸¸æˆå¯¹åœ°å®šä¹‰åœ¨ç›¸åº”çš„è¡¨é¢primitivesä¹‹é—´ï¼ˆæ¯”å¦‚ï¼Œç‚¹-ä¸‰è§’å½¢ï¼Œè¾¹-è¾¹ï¼‰ï¼› ç°æœ‰æ–¹æ³• åˆ©ç”¨éçº¿æ€§ä»£ç†å‡½æ•°ä»¥åŠå®ƒä»¬çš„çº¿æ€§åŒ–å½¢å¼ï¼Œå®šä¹‰ä¸€ä¸ªå±€éƒ¨çš„æœ‰å‘è·ç¦»çš„è¯„ä¼°ã€‚æ­¤ç±»æ–¹æ³•åŒ…æ‹¬ çº¿æ€§æ§½(gap)å‡½æ•° ç”±å‡ ä½•æ³•å‘é‡è®¡ç®—çš„çº¿æ€§çº¦æŸ æœ‰å‘ä½“ç§¯çº¦æŸ è¿™äº›éçº¿æ€§ä»£ç†(nonlinear proxies)å­˜åœ¨é—®é¢˜ï¼šåªæ˜¯å±€éƒ¨æœ‰æ•ˆçš„ï¼Œå› æ­¤ä¼šå¼•å…¥ artificial ghost contact force (å½“å—å‰ªåˆ‡åŠ›æ—¶) false positives (å½“æ—‹è½¬æ—¶) discontinuities (å½“ç©¿è¶Šè¡¨é¢å…ƒç´ è¾¹ç•Œæ—¶) åŒæ—¶ï¼Œå¾ˆå¤šæ–¹æ³•éœ€è¦ è¿›ä¸€æ­¥çš„çº¿æ€§åŒ– ä»¥æ±‚è§£ä¸€ä¸ªå¸¦çº¦æŸçš„æ—¶é—´æ­¥é•¿ã€‚ æ§½å‡½æ•°æ³• or â€œæ¥è§¦ç‚¹å’Œæ³•å‘é‡â€æ³•ï¼šé€šè¿‡æŠŠ ä¸€ä¸ªä¸¤ä¸¤primitivesä¹‹é—´çš„çº¿æ€§åŒ–çš„è·ç¦»é‡ å±€éƒ¨åœ°æ˜ å°„åˆ° ä¸€ä¸ªå›ºå®šçš„å‡ ä½•æ³•å‘é‡ä¸Šï¼Œæ¥è¿‘ä¼¼primitivesä¹‹é—´çš„SDFã€‚ å­˜åœ¨é—®é¢˜ï¼š è¿­ä»£çš„æˆåŠŸç‡ ä¸ ç½‘æ ¼è¡¨é¢çš„å˜åŒ– æ•æ„Ÿï¼ˆhighly varied results; largely dependent on the scene; highly sensitive to surface variations with well-known failure modesï¼‰ fictitious domainæ³• 3.2 Implicit Time Step Algorithms for Contact - æ¥è§¦çš„éšå¼æ—¶é—´æ­¥é•¿ç®—æ³•contact constraint proxy the solve for the implicit time step is the minimization of the contact-constraint IP 3.3 Friction - æ‘©æ“¦Maximal Dissipation Principle (MDP) 3.4 Barrier Functions - éšœç¢å‡½æ•°3.5 æ€»ç»“ç°åœ¨çš„contact simulationçš„æ–¹æ³•å¯¹æ¯ä¸€ä¸ªå®ä¾‹æ˜¯å¾ˆæœ‰æ•ˆçš„ï¼Œä½†æ˜¯åŸºæœ¬ä¸Šéƒ½è¦å¾ˆè´¹åŠ²åœ°è°ƒå‚æ‰èƒ½æˆåŠŸï¼ˆå³å¾—åˆ°ç¨³å®šã€ä¸äº¤å‰ã€plausibleæˆ–å¯é¢„æµ‹çš„ç»“æœï¼‰ã€‚è€Œä¸”å¾ˆå¤šè°ƒçš„å‚æ•°éƒ½ä¾èµ–äºå¤§é‡çš„æ•°æ®ï¼Œè€Œä¸æ˜¯åŸºäºç‰©ç†ã€‚Towardsä¸€ä¸ªç›´æ¥çš„ã€â€plug and playâ€çš„æ¥è§¦ä»¿çœŸæ¡†æ¶ï¼Œæˆ‘ä»¬æå‡ºIPCï¼Œå¯¹äºå„ç§å„æ ·çš„ç½‘æ ¼åˆ†è¾¨ç‡ã€æ—¶é—´æ­¥é•¿ã€ç‰©ç†æ¡ä»¶ã€ææ–™å‚æ•°ã€å¤§å½¢å˜ï¼Œæˆ‘ä»¬éƒ½ç¡®è®¤äº†IPCä¸éœ€è¦æ¡ä»¶ç®—æ³•çš„å‚æ•°ã€‚ 4 Primal Barrier Contact Mechanics \\begin{array}{lc} \\hline \\text { Algorithm } 1 \\text { Barrier Aware Projected Newton } \\\\ \\hline \\text { 01: procedure BarrierAwareProjectedNewton }\\left(x^{t}, \\boldsymbol{\\epsilon}\\right) \\\\ \\text { 02: } \\quad \\quad x \\leftarrow x^{t} \\\\ \\text { 03: } \\quad \\quad \\hat{C} \\leftarrow \\text { ComputeConstraintSet }(x, \\hat{d}) \\rightarrow Section\\ 4.6,6.1\\\\ \\text { 04: } \\quad \\quad E_{\\text {prev }} \\leftarrow B_{t}(x, \\hat{d}, \\hat{C}) \\\\ \\text { 05: } \\quad \\quad x_{\\text {prev }} \\leftarrow x \\\\ \\text { 06: } \\quad \\quad \\text {do } \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad\\quad \\quad \\quad \\quad \\quad \\quad \\quad \\triangleright \\text { Section 4.6,6.1} \\\\ \\text { 07: } \\quad \\quad \\quad \\quad H \\leftarrow \\operatorname{SPDProject}\\left(\\nabla_{x}^{2} B_{t}(x, \\hat{d}, \\hat{C})\\right) \\rightarrow Section\\ 4.3\\\\ \\text { 08: } \\quad \\quad \\quad \\quad p \\leftarrow-H^{-1} \\nabla_{x} B_{t}(x, \\hat{d}, \\hat{C}) \\\\ \\text { 09: } \\quad \\quad \\quad \\quad \\text{//CCD line search}: \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\triangleright \\text { Section 4.4}\\\\ \\text { 10: } \\quad \\quad \\quad \\quad \\alpha \\leftarrow \\min (1, \\text { StepSizeUpperBound }(x, p, \\hat{C})) \\\\ \\text { 11: } \\quad \\quad \\quad \\quad \\text {do } \\\\ \\text { 12: } \\quad \\quad \\quad \\quad \\quad \\quad x \\leftarrow x_{\\text {prev }}+\\alpha p \\\\ \\text { 13: } \\quad \\quad \\quad \\quad \\quad \\quad \\hat{C} \\leftarrow \\text { ComputeConstraintSet }(x, \\hat{d}) \\\\ \\text { 14: } \\quad \\quad \\quad \\quad \\quad \\quad \\alpha \\leftarrow \\alpha / 2 \\\\ \\text { 15: } \\quad \\quad \\quad \\quad \\text {while } B_{t}(x, \\hat{d}, \\hat{C})>E_{\\text {prev }} \\\\ \\text { 16: } \\quad \\quad \\quad \\quad E_{\\text {prev }} \\leftarrow B_{t}(x, \\hat{d}, \\hat{C}) \\\\ \\text { 17: } \\quad \\quad \\quad \\quad x_{\\text {prev }} \\leftarrow x \\\\ \\text { 18: } \\quad \\quad \\quad \\quad \\text {Update } \\kappa, \\text { BCs and equality constraints } \\quad \\triangleright \\text { Supplemental } \\\\ \\text { 19: } \\quad \\quad \\text { while } \\frac{1}{h}\\|p\\|_{\\infty}>\\epsilon_{d} \\\\ \\text { 20: } \\quad \\quad \\text { return } x \\\\ \\hline \\end{array}4.1 Barrier-augmented Incremental Potential - å¸¦éšœç¢å‡½æ•°çš„å¢é‡åŠ¿to enforce for all , we construct a continuous barrier energy (å±€éƒ¨çš„æ’æ–¥åŠ›ï¼Œåªæœ‰å°†è¦ç¢°æ’æ—¶æ‰æœ‰æ•ˆ) å®šä¹‰ barrier augmented IPï¼š. 4.2 Smoothly Clamped Barriers - å¹³æ»‘æˆªæ–­çš„éšœç¢å‡½æ•°éœ€è¦clampçš„åŸå› ï¼šç®€å•åœ°è®¡ç®—energyä¼šå¯¼è‡´çš„å¤æ‚åº¦ï¼Œå¾ˆå¤šä»¿çœŸæ–¹æ³•åªæ˜¯ç®€å•åœ°å»æ‰è·ç¦»è¾ƒè¿œçš„primitivesä¹‹é—´çš„çº¦æŸï¼ˆè®¤ä¸ºå®ƒä»¬ä¸ä¼šç¢°æ’ï¼‰ï¼Œè¿™ç§æ“ä½œå¾ˆå±é™©ï¼Œå¯èƒ½å¯¼è‡´ä¸ç¨³å®šã€é”™è¿‡å¯èƒ½çš„ç¢°æ’ã€‚æˆ‘ä»¬è®¾è®¡å¹³æ»‘çš„barrierå‡½æ•°ï¼Œä»è€Œåœ¨å‡†ç¡®é«˜æ•ˆåœ°è®¡ç®—æ‰€æœ‰çº¦æŸçš„barrier energyçš„åŒæ—¶åªéœ€è€ƒå¯Ÿprimitive pairsçš„ä¸€ä¸ªå°å­é›†ã€‚ computational distance accuracy target æˆ– clamping thrshold (= in Section 2) barrier function b(d,\\hat{d})=\\left\\{\\begin{aligned}&-(d-\\hat{d})ln(d/\\hat{d}),&0 \\\\& 0,&d\\geq\\hat{d}\\end{aligned}\\right. culled constraint set 4.3 Newton-type Barrier Solver - ç‰›é¡¿å‹éšœç¢å‡½æ•°çš„æ±‚è§£å™¨ projected Newton (PN) ï¼šä¸€ç§äºŒé˜¶æ— çº¦æŸä¼˜åŒ–ç­–ç•¥ï¼Œç”¨äºæœ€å°åŒ–éçº¿æ€§éå‡¸å‡½æ•°ï¼ˆä¸”Hessianå¯èƒ½indefiniteï¼‰ barrier Hessian çš„å½¢å¼æ˜¯ 4.4 Intersection-aware Line Search (filter)çµæ„Ÿæ¥æºï¼šinversion-aware line search filter[2] where our contact forces are given by barrier derivatives æ³¨ï¼šbarrierè¶‹äºæ— ç©·ä¸èƒ½ä¿è¯ä¸ç›¸äº¤ï¼Œè€Œæ˜¯è¿™é‡Œçš„Intersection-aware Line Searchä¿è¯äº†IPCçš„ä¸ç›¸äº¤ï¼ 4.5 IPC Solution Update4.6 Constraint Set Update and CCD Acceleration6 Distance Computation6.1 Combinational Distance Computationfor pair of primitives ï¼ˆ*primitiveæŒ‡point, edge or triangle.ï¼‰ point-triangle distance . edge-edge distance . primitive-primitive diatance two constraints: , where and are and , or two endpoints of edges in edge-edge pair. single constraint: , where â€¦ no constraints: . è¿™æ ·â€œæ— ç©¿é€â€ä¸‰ä¸ªå­—å°±å¯ä»¥åœ¨ä»»æ„æƒ…å†µä¸‹å‡†ç¡®ä¸¥è°¨åœ°è¡¨è¾¾ä¸ºï¼š . è™½ç„¶æˆ‘ä»¬çš„å’Œå…¶å®éƒ½å¯ä»¥æ ¹æ®ç›¸å¯¹ä½ç½®å…³ç³»å†™æˆè¿ç»­åˆ†æ®µè§£æå‡½æ•°ï¼Œæˆ‘ä»¬å¯¹â€œæ— ç©¿é€â€ä¸‰ä¸ªå­—çš„æ•°å­¦æè¿°è¿˜æ˜¯å¾ˆæ˜‚è´µçš„ï¼ša å¯ä»¥å–0åˆ°1ä¹‹é—´æ— ç©·ä¸ªå®æ•°ï¼Œk çš„ä¸ªæ•°åˆ™æ˜¯ç‰©ä½“è¡¨é¢ç‚¹ã€è¾¹ã€ä¸‰è§’å½¢æ•°é‡çš„äºŒæ¬¡æ–¹çº§åˆ«çš„ï¼ è€ŒIPCçš„è§£å†³æ–¹æ¡ˆï¼Œå°±æ˜¯å·§ç”¨è¿ç»­ç¢°æ’æ£€æµ‹(CCD)æ¥å¯¹ä»˜aï¼Œå¹¶æ„é€ å…‰æ»‘çš„å±€éƒ¨éšœç¢å‡½æ•°æ¥å¯¹ k é™ç»´ï¼ anyway å¸¦çº¦æŸçš„æœ€å°åŒ–é—®é¢˜ï¼š å³æ— ç©¿é€. é—®é¢˜è½¬åŒ–æˆæ— çº¦æŸçš„æœ€å°åŒ–é—®é¢˜ . reference [1] Li - 2020 - IPC. [2] Smith - 2015 - Bijective parameterization with free boundaries. .markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}} const mindmaps = document.querySelectorAll('.markmap-svg'); for(let mindmap of mindmaps) { markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML)); }","link":"/2021/12/30/IPC/"},{"title":"Implicit Geometric Regularization","text":"I looked into the paper 'Implicit Geometric Regularization for Learning Shapes' and did a presentation on it.","link":"/2021/12/11/Implicit-Geometric-Regularization/"},{"title":"Material_Point_Method(MPM)","text":"MPM - Definition a hybrid Lagrangian/Eulerian discretization scheme for solid mechanics (MLS-2018-Hu) the generalization of Particle In Cell (PIC) and Fluid Implicit Particle Method (FLIP) to solid mechanics.(MPM course-2016-Jiang) MPM - Features (MPM course-2016-Jiang) combine Lagrangian material particles (points) with Eulerian Cartesian grids. no inherent need for Lagrangian connectivity. implicitly handle self-collision and fracture with the background Eulerian grid. Continuum Theory (MPM course-2016-Jiang) Continuum assumption can be made for almost all solids and liquids, including deformable (elastic and plastic)objects, muscle, flesh, cloth, hair, liquid, smoke, gas, granular materials (sand, snow, mud, soil, etc.). A continuum body defines quantities such as density, velocity and force as continuous functions of position. The main focus of continuum kinematics/motion is the deformation, either locally or globally in different coordinate systems of interests. Luckily in most cases, we can describe kinematics without introducing the meaning of force, stress or even mass.","link":"/2021/12/06/Material-Point-Method-MPM/"},{"title":"NeRF","text":"NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis NeRF repository contributions neural radiance fields network or ï¼Œwhere only relies on . volume rendering color , where transmittance , ray . radiance field: the color radiating from point in direction . stratified sampling for integral estimation evenly partition into bins, then sample uniformly at random in each bin. color , where , . æ³¨æ„ï¼šé‡‡æ ·åå˜æˆäº†ï¼ˆç”¨åˆ°äº†exp(x)-&gt;x+1(x-&gt;0)çš„è¿‘ä¼¼ï¼‰ï¼›åœ¨è¡¨è¾¾å¼ä¸­ï¼Œé‡‡æ ·å€¼ä¹˜åŒºé—´é•¿åº¦ä»£æ›¿äº†ç§¯åˆ†ã€‚ é—®é¢˜ï¼šè¿™é‡Œèƒ½ç”¨Monte-Carolä¼°è®¡ç§¯åˆ†å—?","link":"/2021/11/30/NeRF/"},{"title":"Volume_Rendering","text":"my Thoughts volume rendering ä¼˜ç‚¹ï¼šç»Ÿä¸€ transparent å’Œ opaque ç‰©ä½“çš„æ¸²æŸ“æ–¹æ³•ï¼Œå¦‚æ¯›å‘ã€çƒŸé›¾ç­‰ï¼› ç¼ºç‚¹ï¼šè®¡ç®—é‡è¿œå¤§äºsurface renderingï¼›å­˜å‚¨é‡å¤§ï¼Ÿ é€šè¿‡opacityæ¥ç¡®è®¤occlusion in NeRF-2020 color , where transmittance , ray . radiance field æŒ‡ stratified sampling for integral estimation: do random uniform sample in each even partition . å³ , is the number of partitions. color , where , . æ³¨ï¼šé‡‡æ ·åæ¢æˆäº†ï¼Œåˆ©ç”¨ï¼› æ³¨ï¼šåœ¨è¡¨è¾¾å¼ä¸­ï¼Œé‡‡æ ·å€¼åŒºé—´é•¿åº¦ä¹‹ç§¯ä»£æ›¿äº†ç§¯åˆ†ã€‚ in Volume Rendering of Neural Implicit Surfaces-2021-Yariv paper page \"In essence, volume rendering is all about approximating the integrated light radiance along this ray reaching the camera.\" \"ä½“æ¸²æŸ“çš„æœ¬è´¨ï¼šä¼°è®¡ç§¯åˆ†\" transparency (same as NeRF) opacity , , , and it is monotonic increasing. weight is a PDF (Probability Density Function) color , where is radiance field æ³¨ï¼šè¿™é‡Œçš„ ç›¸å½“äºNeRFé‡Œçš„ ï¼Œåªæ˜¯å¢åŠ äº†å¯¹è¾¹ç•Œæ³•å‘é‡ çš„ä¾èµ–ã€‚ \"NeRF is heavily affected by the sampled point during intensity calculation.\" é‡‡æ ·æ–¹æ³•çš„é—®é¢˜ï¼š NeRFçš„ \"random uniform sample\" ä¼šé€ æˆ artifactsï¼› è‹¥æ”¹æˆ \"fixed uniform sample\" ä¼šé€ æˆå¦ä¸€ç§ artifactsï¼› in Neural Volumes: Learning Dynamic Renderable Volumes from Images-2019-Lombardi paper page ï¼ˆ*æœ¬æ–‡æœ€æ—©æŠŠvolume renderingç”¨äºnovel view synthesisï¼‰ from Section 6.1 Semi-Transparent Volume Rendering \"If the accumulated opacity reaches 1 (for example, when the ray traverses an opaque region), then no further color can be accumulated on the ray\"","link":"/2021/11/29/Volume-Rendering/"},{"title":"approaches & methods","text":"Descent Methods Gradient Descent: . Newton's method: . Quasi-Newton methods: Nonlinear Conjugate Gradient(CG): , . Numerical Procedure Designs Position Based Dynamics (PBD): build a projection for every constraint Projective Dynamics: uses the projection in energy corotational FEM method: can be seen as as projective dynamics with rotation as projection Iterative Linear Solvers Gauss-Seidel: Jacobi: Conjugate gradients: acceleration methods Chebyshev Semi-Iterative Method: Nesterov's Method:","link":"/2021/12/20/approaches/"},{"title":"cloth simulation","text":"Method 1: Newton's Method + Jacobi Method with Chebyshev Acceleration Newton's method is also called backward Euler or implicit Euler Method 2: Position Based Dynamics + a Jacobi Approach To avoid bias of Gauss-Seidel Approach, we adopt Jacobi Approach. notes on PBD: 'Position based' is relative to 'force based'. PBD updates position first, while force-based methods update velocity first. Update of position is based on projection (a map from to ). See 'A Survey on Position Based Dynamics, 2017' for more detail. See 'ã€æ·±å…¥æµ…å‡º Nvidia FleXã€‘(1) Position Based Dynamics' for a concise introduction. Reference [1] Huamin Wang's GAMES103 course","link":"/2021/12/12/cloth-simulation/"},{"title":"collision simulation","text":"Collision Detection Pipeline Broad-Phase Collision Culling Spatial Hashing (SH) Easy to implement GPU friendly Needs to recompute after updating objects Bounding Volume Hierarchy (BVH) More involved Not GPU friendly To update BVH, just update bounding volumes Pairs edge-triangle pair, or vertex-triangle and edge-edge pairs Narrow-Phase Collision Test Discrete Collision Detect (DCD) issues with DCD Continuous Collision Detect (CCD) issues with CCD Floating-point errors, especially due to root finding of a cubic equation Buffering epsilons, but that causes false positives. Gaming GPUs often use single floating-point precision. Computational costs: more expensive than DCD. Some argue that broad-phase collision culling is the bottleneck. Difficulty in implementation. Collision Response Two methods: Interior Point Method &amp;&amp; Impact Zone Optimization. Interior Point Method Log-Barrier implementation Impact Zone Optimization We can also turning this into an unconstraint optimization problem: Augmented Lagrangian pros &amp; cons Reference [1] Huamin Wang's GAMES103 course, 09_collision [2] Incremental Potential Contact-2020-Li","link":"/2022/01/05/collision-simulation/"},{"title":"elastic simulation","text":"Deformation undeformed/reference configuration deformed configuration deformation map deformation gradiant or ( is the Jacobian matrix of ) Strain &amp; Hyperelasticity strain energy note: for hyperelastic materials, only depends on (or the initial and final configurations and ) and not on the deformation path over time (or equivalently, the elastic forces of hyperelastic materials are conservative). energy density measures the strain energy per unit undeformed volume on an infinitesiml domain around the mateiral point using first-order Taylor expansion thus, is a function of alone, i.e. . Force &amp; Traction force density aggragate force on a finite region is . traction (surface force density) aggragate force on a finite boundary region is . Stress 1st Piola-Kirchhoff stress (a 3*3 matrix or tensor, short as PK1 stress) where is outward normalunit normal to the boundary in the undeformed configuration. or for hyperelastic materials, note Much literature define and because and are seen as external. However, such definitions are only true when the body is in an equilibrium configuration. We retain our original definition above and denote external force and traction as and . Strain Green strain (tensor) if we do polar decomposition deformation gradient as , then small/infinitesimal strain (tensor, a linear approximation of ) ğŸ‡ Linear Elasticity . where . . ğŸ‡ Neo-Hookean Elasticity . where (the same as linear elasticity), is dimension. . the most often used elasticity model in CG. ğŸ‡ St. Venant-Kirchhoff Elasticity Replacing strain in Linear Elasticity with , we get . . in energy density , is against stretch, is against volume change. rotational invariant, but with quartic complexity. Elasticity Modeling Procedures Given , for each tetrahedron (the simplest finite element in 3D, often used in CG), pre-compute (the volume) and (the inverse of the reference edge matrix). Update by Newton's (, ) to get , then calculate . Now we can get gradient , stress (according to its formula in each elasticity model). Finally, calculate force and Update by Newton's. ğŸ‡ Corotated Linear Elasticity Replacing strain in Linear Elasticity with (by polar decomposition ), we get where is from singular value decomposition (SVD) . rotational invariant, but the polar decomposition is computationally costly. Rotationally Invariant &amp; Isotropic rotationally invariant: if and only if . isotropic: if and only if . Using SVD , we conclude that rotationally invariant and isotropic materials satisfy . Invariants right Cauchy Green tensor . Using SVD , with . . invariants . . . reference [1] SIGGRAPH 2012 Course \"FEM Simulation of 3D Deformable Solids: A practitioner's guide to theory, discretization and model reduction\"","link":"/2021/12/15/elastic-simulation/"},{"title":"linear solver","text":"Problem Solvers Iterators Gauss-Seidel iteration Jacobi Jacobi v.s. Gauss-Seidel [2] Conjugate gradients Reference [1] Huamin Wang's GAMES103 course and Yuanming Hu's GAMES201 course [2] Bouaziz - 2016 - Projective dynamics: Fusing constraint projections for fast simulation.","link":"/2021/12/13/linear-solver/"},{"title":"multigrid","text":"Model Problem One-dimensional boundary value problem . . grid . è®¾å’Œï¼Œ. Approximate using Taylor series, we get . The problem turns into . . Let å’Œ. çŸ©é˜µå½¢å¼ï¼Œå…¶ä¸­æ˜¯N-1é˜¶å¯¹ç§°æ­£å®šçŸ©é˜µï¼Œ . è§£æ³•ï¼š Direct é«˜æ–¯æ¶ˆå…ƒï¼ˆGaussian eliminationï¼‰ å› å¼åˆ†è§£ï¼ˆFactorizationï¼‰ Iterative Jacobi Gauss-Seidel Conjugate Gradient Iterative Methods for Linear Systems Consider and let be an approximation to . error , with norms , . residual , with norms , . residual equation . residual correction . Relaxation Schemes Consider the 1D model problem . Jacobi Relaxation . Let where is diagonal and and are the strictly lower and upper parts of . Then becomes Let , subtracting from , we get . Weighted Jacobi Relaxation . . Gauss-Seidel Relaxation . , as well, then . Let Red-Black Gauss-Seidel Relaxation even (red) points: . odd (black) points: . note: Jacobi and Red-Black Gauss-Seidel are both suitable for parallel computation. Analysis of stationary iterations Let . The exact solution is unchanged by the iteration, i.e., . . . Fundamentals of Fourier Fourier modes , component , mode/frequency . Fundamentals of iteration convergence factor . is convergent ( as ) if and only if . asymptotic(æ¸è¿‘çº¿çš„) convegence rate . *note: the number of iterations needed to reduce the error by : . Convergence of Jacobi &amp; weighted Jacobi on Au=0 relaxation matrix , eigenvalues . (let ) , where . . and have the same eigenvectors , with its component , , . meaning of eigenvalues Expand the initial error with eigenvectors: After iterations, . The mode of the error is reduced by at each iteration. choice of weight Note that if then for ï¼ˆå³æ‰€æœ‰é¢‘ç‡éƒ½ä¼šè¡°å‡ï¼‰ ä½†long waves()åœ¨ä»»ä½•ä¸‹éƒ½å‡ ä¹ä¸è¡°å‡ï¼Œå¦‚. Choose a that best dump the short waves(): let . smoothing factor For , with , experiment Jacobi method on with . Number of iterations required to reduce to . Initial guess: . Important conclusion(*) Many relaxation shemes have the smoothing property, where oscillatory modes of the error are eliminated effectively, but smooth modes are damped very slowly. or say, Relaxation is most effective on oscillatory error modes. Convergence of Gauss-Seidel on Au=0 . . . and have different eigenvectors, Gauss-Seidel mixes the modes of . Multigrid ideas fine grid(fg) : separated into with grid length . coarse grid(cg) : separated into with grid length . Nested Iteration use cg compute an improved initial guess for fg relxation. Relaxation on cg is much cheaper (1/2 in 1D, 1/4 in 2D, 1/8 in 3D). Relaxation on cg has a marginally better convergence rate, e.g. instead of . procedures: ... Relax on on to obtain intial guess . Relax on on to obtain intial guess . Relax on on to obtain the final solution. But, what is on , , ...? What if the error still has smooth components when we get to the fine grid ? Coarse-Grid Correction use error relaxed on cg to correct the approximation . Smooth error is more oscillatory in cg, thus relaxation is more effective. (See conclusion(*)). Use the residual equation to relax on the error . But, what does it mean to relax on on ? How to relax on and what initial guess should be used? How do we transfer the error estimate from back to ? Intergrid transfer operators For , the mode is preserved on cg. (the superscript indicates the grids on which the vectors are defined). For , the mode on fg becomes mode on cg. (called aliasing) . Prolongation operator Considering the 1D case, , where , for . We may regard as a linear operator from to . e.g. for , has full rank, and thus null space is empty set ï¼ˆå³æ— è§£ï¼‰. If is smooth, approximate very well. If is oscillatory, approximate not well. Therefore, Nested Iteration is most effective when the error is smooth. Restriction operator Considering the 1D case, restriction by injection: , where . restriction by full-weighting: , where . In the discussion that follows, we use full weighting as a restriction operator. We may regard as a linear operator from to . e.g. for , has rank , and thus . Relation between prolongation and restriction A commonly used and highly useful requirement is , for in . The fact that the interpolation operator and the full weighting operator are transposes of each other up to a constant is called a variational property and will soon be of importance. Two-Grid Correction Scheme : Relax times on on with initial guess . Compute residual: . Restrict (transfer to cg): . Relax several times on on with initial guess . Prolongate/Interpolate (transfer to fg): . Correct the approximation . Relax times on on with intial guess . What is ? ? How to solve the cg residual equation? Recursion! Schemes for solving residual equation V-Cycle Scheme . Relax times on with a given initial guess . If , then go to step 4. Else , -- , -- initial guess . Correct . Relax times on with initial guess . The V-cycle is just one of a family of multigrid cycling schemes. The entire family is called the Âµ-cycle method and is defined recursively by the following. -Cycle Scheme Âµ. Relax Î½1 times on Ahuh = fh with a given initial guess vh. If â„¦h = coarsest grid, then go to step 4. Else f2h â† I2h h (fh - Ahvh), v2h â† 0, v2h â† MÂµ2h(v2h,f2h) Âµ times. Correct . Relax Î½2 times on Ahuh = fh with initial guess vh. In practice, only Âµ = 1 (which gives the V-cycle) and Âµ = 2 are used.","link":"/2022/01/13/multigrid/"},{"title":"my FEM elastic simulation with Unity","text":"I finished Huamin Wang's GAMES103 homework 3. results: St. Venant Kirchhoff Model: Neo-Hookean Model + SVD (the 'principal stretches' or 'matrix invariants' method) A late Merry Christmas to myself ! â„ğŸ„ğŸ…ğŸ”¥ğŸ˜Š 2021.12.26","link":"/2021/12/26/my-FEM-elastic-simulation-with-Unity/"},{"title":"rigid body collision","text":"Method: Shape Matching Basic Idea: first handle collision and friction of vertices independetnly, then enforce constraint to restore regidity. Advantages: Easy to implement and compatible with other nodal systems, i.e., cloth and soft bodies. Disadvantages: Difficult to strictly enforce friction and other goals. (The rigidification process will destroy them.) Suggestion: More suitable when the friction accuracy is less important, i.e., buttons on clothes. Reference Huamin Wang's GAMES103 course","link":"/2021/12/11/rigid-body-collision/"},{"title":"time integration","text":"integrators forward Euler (explicit Euler): semi-implicit Euler (symplectic) backward Euler (implicit Euler) or Newton's method: (see one of the applications of this method here) comparison: explict vs. implict explict (forward Euler, symplectic Euler, RK, ... ) easy to implement, future only relies on past. ğŸ˜Ÿeasy to explode: , especially for stiff materials. implicit (backward Euler, middle-point, ... ) future relies on past &amp; future, need to solve equations. support larger time step (robustness, thus the mainstream) ğŸ˜Ÿnumerical damping &amp; locking. unifying CFL condition , where is CFL number, is time step, is length interval (e.g. particle radius, grid size), is maximum (velocity) Typical : SPH: MPM: FLIP fluid (smoke): reference [1] Yuanming Hu - ppt in the course GAMES201. [2] Bouaziz - 2016 - Projective dynamics: Fusing constraint projections for fast simulation.","link":"/2021/12/13/time-integration/"},{"title":"Projective Dynamics","text":"h Position Based Dynamics (PBD): build a projection for every constraint Projective Dynamics: uses the projection in energy Projective Dynamics ä¸»è¦æ€æƒ³ï¼šé€šè¿‡å®šä¹‰è¾…åŠ©å˜é‡ï¼ŒæŠŠä¸€ä¸ªå¤§è§„æ¨¡éçº¿æ€§éå‡¸ä¼˜åŒ–é—®é¢˜ï¼Œæ‹†è§£æˆglobalå¤§è§„æ¨¡äºŒæ¬¡å‡¸ä¼˜åŒ–é—®é¢˜+localå¤šä¸ªå°è§„æ¨¡éçº¿æ€§éå‡¸ä¼˜åŒ–é—®é¢˜ï¼Œåœ¨globalå’Œlocalä¹‹é—´è½®ç•ªè¿­ä»£æ±‚è§£ã€‚ åº”ç”¨èŒƒå›´ï¼šå¼¹ç°§è´¨ç‚¹æ¨¡å‹[4]ã€æœ‰é™å…ƒæ¨¡å‹[1]ã€ åˆ†ç±»ï¼šan implicit integration solver continuum mechanics (physics-based) + PBD æ³¨ï¼šè¿ç»­ä½“åŠ›å­¦(continuum mechanics): â€œå¼¹æ€§ä½“çš„å½¢å˜â€ ç”± â€œå¼¹æ€§åŠ¿èƒ½(elastic potential energy)â€ æ¥é‡åŒ–ã€‚é—®é¢˜åœ¨äºï¼šå¼¹æ€§åŠ›å¾€å¾€éçº¿æ€§ï¼Œä½¿è¿åŠ¨æ–¹ç¨‹çš„æ—¶é—´ç§¯åˆ†å˜å¾—å¤æ‚ã€‚ å¼•å…¥è¿ç»­ä½“åŠ¨åŠ›å­¦çš„æ€è·¯ï¼šcontinuous deformation energies -&gt; a specific set of constraints -&gt; potentials: a convex quadratic measure from a constraint -&gt; local/global optimizations use alternating local/global optimization, generalizing efficient implicit time integration of mass-spring system (Liu-2013-Fast simulation of mass-spring system) local step: project every element onto the constraint manifold (ç”¨æŠ•å½±æ³•ï¼Œä½¿æ¯ä¸ªå…ƒç´ æ»¡è¶³çº¦æŸ) global step: æ‰¾åˆ°å„ä¸ªçº¦æŸçš„æ˜ å°„çš„æŠ˜ä¸­æ–¹æ¡ˆï¼ŒåŒæ—¶è€ƒè™‘å…¨å±€å½±å“ï¼Œå¦‚æƒ¯æ€§å’Œå¤–åŠ›ã€‚ +Advantages generally, ã€‚ over PBD: physices-based over Newton-based: Newton's needs line search and safeguard against singular or indefinite Hessians to guarantee robustness. Local-Global Iterations PDçš„ç²¾é«“ï¼šalternating (between local &amp; global) solver è§£å†³çš„é—®é¢˜ï¼šNewtonæ³•å¯¹éçº¿æ€§éå‡¸å‡½æ•°çš„ä¼˜åŒ–å¤ªæ…¢ ä»¥ä¸Šé—®é¢˜çš„åŸå› ï¼š æ¯ä¸€æ¬¡è¿­ä»£éƒ½è¦è®¡ç®—éçº¿æ€§å¼¹æ€§åŠ¿èƒ½å‡½æ•°çš„Hessian ï¼ˆå› ä¸ºå¼¹æ€§åŠ¿èƒ½ä¾èµ–äºé¡¶ç‚¹ä½ç½®ï¼‰ï¼› å› ä¸ºéå‡¸ï¼Œæ‰€ä»¥ç®—å‡ºæ¥çš„Hessian å¯èƒ½indefiniteï¼›ï¼ˆè‹¥ä¸æ­£å®šï¼ŒNewtonæ³•å¯èƒ½ç»™å‡ºä¸€ä¸ªä¸Šå‡çš„æ–¹å‘ï¼Œå³æŒ‡æƒ³å±€éƒ¨æå¤§å€¼ç‚¹ï¼‰æ‰€ä»¥è¦ä¹ˆé€‰æ‹©æ­£å®šåŒ–ï¼Œè¦ä¹ˆé€‰æ‹©å…¶ä»–æ–¹æ¡ˆï¼› Local projection compute the target positions of a subgroup of vertices under the i-th constraint. , . , where is selection matrix for the constraints . and are constant matrice, often Laplacian-likeï¼ˆï¼Ÿï¼‰, for a better distance measure. sets the target position of intersecting vertex as it closest projection on the collision plane. nonlinear, but each constraint involves only a few DOFs thus can be parallelized (GPU-friendly). Global solve a standard linear solve for where is the weight of each constraint PD treats collision as a constraint. During simulation, it is refactorized and solved at each L-G ieration as collision constraints vary. reference [1] Bouaziz - 2016 - Projective dynamics: Fusing constraint projections for fast simulation. [2] Intersection-free Deformation on GPU. [3] GAMESWebinar2017-16æœŸ(2)-åˆ˜å¤©æ·». [4] Liu - 2013 - Fast Simulation of Mass-Spring Systems.","link":"/2022/02/02/Projective-Dynamics/"},{"title":"Numerical Optimization","text":"To catch up with common methods on numerical optimization Wolfe conditions = sufficient decrease + curvature condition sufficient decrease: $f(x_k+k p_k) f(x_k)+c{1} _k f_k^T p_k $. curvature condition: . with . A step length may satisfy the Wolfe conditions without being particularly close to a minimizer of , as we show in Figure 3.5. We can, however, modify the curvature condition to force to lie in at least a broad neighborhood of a local minimizer or stationary point of . strong Wolfe conditions . . with . The only difference is that we no long allow to be too positive. Backtracking æ­¥é•¿ä»å¤§åˆ°å°æœç´¢ï¼Œæ‰¾åˆ°ç¬¦åˆsufficient decreaseæ¡ä»¶çš„æœ€å¤§æ­¥é•¿ï¼Œå…å»äº†curvatureæ¡ä»¶ã€‚ Algorithm 3.1 (Backtracking Line Search). â€‹ Choose ; â€‹ Set ; â€‹ repeat until â€‹ ; â€‹ end (repeat) â€‹ Terminate with . where for some constant","link":"/2022/02/05/Numerical-Optimization/"}],"tags":[{"name":"Newton","slug":"Newton","link":"/tags/Newton/"},{"name":"gradient","slug":"gradient","link":"/tags/gradient/"},{"name":"iterative","slug":"iterative","link":"/tags/iterative/"},{"name":"tutorial","slug":"tutorial","link":"/tags/tutorial/"},{"name":"paper","slug":"paper","link":"/tags/paper/"},{"name":"2020","slug":"2020","link":"/tags/2020/"},{"name":"siggraph","slug":"siggraph","link":"/tags/siggraph/"},{"name":"presentation","slug":"presentation","link":"/tags/presentation/"},{"name":"elastic","slug":"elastic","link":"/tags/elastic/"},{"name":"simulation","slug":"simulation","link":"/tags/simulation/"},{"name":"method","slug":"method","link":"/tags/method/"},{"name":"mpm","slug":"mpm","link":"/tags/mpm/"},{"name":"ECCV","slug":"ECCV","link":"/tags/ECCV/"},{"name":"rendering","slug":"rendering","link":"/tags/rendering/"},{"name":"neural","slug":"neural","link":"/tags/neural/"},{"name":"sum-up","slug":"sum-up","link":"/tags/sum-up/"},{"name":"cloth","slug":"cloth","link":"/tags/cloth/"},{"name":"PBD","slug":"PBD","link":"/tags/PBD/"},{"name":"Jacobi","slug":"Jacobi","link":"/tags/Jacobi/"},{"name":"Chebyshev","slug":"Chebyshev","link":"/tags/Chebyshev/"},{"name":"Gauss-Seidel","slug":"Gauss-Seidel","link":"/tags/Gauss-Seidel/"},{"name":"collision","slug":"collision","link":"/tags/collision/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"rigid","slug":"rigid","link":"/tags/rigid/"},{"name":"implicit","slug":"implicit","link":"/tags/implicit/"},{"name":"Lagrangian","slug":"Lagrangian","link":"/tags/Lagrangian/"},{"name":"CCD","slug":"CCD","link":"/tags/CCD/"},{"name":"DCD","slug":"DCD","link":"/tags/DCD/"},{"name":"BVH","slug":"BVH","link":"/tags/BVH/"},{"name":"SH","slug":"SH","link":"/tags/SH/"},{"name":"Interior Point Method","slug":"Interior-Point-Method","link":"/tags/Interior-Point-Method/"},{"name":"Impact Zone Optimization","slug":"Impact-Zone-Optimization","link":"/tags/Impact-Zone-Optimization/"},{"name":"optimization","slug":"optimization","link":"/tags/optimization/"},{"name":"Projective Dynamics","slug":"Projective-Dynamics","link":"/tags/Projective-Dynamics/"}],"categories":[]}