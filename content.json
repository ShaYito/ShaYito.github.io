{"pages":[{"title":"about","text":"A senior undergraduate student fascinated by and dedicated to computer graphics. NewsI accepted the offer from Clemson University as a PhD in computer graphics with Prof. Yin Yang starting in 2022 fall. —2022.1.25 Interestscomputer graphics, simulation and physics-based animation, shape reconstrution, physics-based rendering ExperiencesResearch Project: Precise Calibration and Modeling of Piezo-resistive Textile 2020.3-2021.9 Advisor: Prof. Jingyuan Cheng, School of Computer Science and Technology, USTC ◦ Realized a mathematical model to predict the nonlinear behavior of piezoresistive textile ◦ Built a finite-element physical model of the textile EducationBachelor of Engineering in Electronic Science and Technology at University of Science and Technology of China, 2018-2022 Skills◦ Python (4000 lines, including Taichi) ◦ C++ (3000 lines, including OpenGL) ◦ C# (1200 lines, for Unity) ◦ MATLAB (500 lines) ◦ COMSOL (finite-element simulation, on Structural Mechanics and Electromagnetics) ◦ Cinema 4D (created animations for fun) Contacte-mail: shayito_@outlook.com","link":"/about/"},{"title":"links","text":"Useful Links GAMES (Graphics And Mixed Environment Seminar) Siggraph paper collection Thanks to The author of this hexo theme A great blog framework: hexo","link":"/links/"},{"title":"tags","text":"","link":"/tags/"}],"posts":[{"title":"Descent Optimization","text":"Algorithm Initialize ; for do ​ Calculate the descent direction ; ​ Adjust the step length ; ​ ; ​ ; return ; Descent Methods As long as descent direction satisfies , it is a possible descent direction. method descent direction note advantage disadvantage Gradient Descent . can be viewed as updating by force; simple; linear convergence rate; similar to explicit time integration, thus step leangth must be small; Newton's method , is the Hessian matrix of . note: not always descending, unless is positive definite. solve linear equation every iteration; quadratic convergence, the fastest; computationally expensive, not real-time; cannot be easily parallelized on GPU; Quasi-Newton methods approximate the Hessian matrix or its inverse, e.g., BFGS, L-BFGS. it's sequential by nature; less cost per iteration than Newton's; difficult to run on GPU, unless subject to box constraint; Nonlinear Conjugate Gradient(CG) where . generalization of Conjugate Gradient; highely similar to L-BFGS with ; much more friendly with GPU acceleration than quasi-Newton; still require multiple dot product operations, which restrict its performance on the GPU; total cost = per interation cost * number of iterations Reference [1] Parallel Iterative Solvers for Real-time Elastic Deformations - course notes. [2] Huamin Wang's GAMES103 course","link":"/2021/12/23/Descent-Optimization/"},{"title":"CUDA10.2+VS2019+win10 configuration","text":"Create a new Empty Project in VS2019, set \"Solution Platforms\" as \"x64\". Right click &lt;Your Project Name&gt;-Build Dependencies-Build Customizations, check CUDA xxxx. (If you cannot find this option, go to C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\extras\\visual_studio_integration\\MSBuildExtensions, copy CUDA 10.2.props to C:\\Program Files (x86)\\MSBuild\\Microsoft.Cpp\\v4.0\\BuildCustomizations replacing the existing CUDA 10.2.props file. See here. Tools-Options-Projects and Solutions-VC++ Project Settings-Extensions To Include: add \".cu\". Right click &lt;Your Project Name&gt;-Properties, make sure Configuration above is always \"All Configurations\" &amp; \"x64\". On this page, go toVC++ Directories in Include Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\include; in Library Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64; go to Linker-General in Additional Library Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64; go to Linker-Input in Additional Dependencies, add files inside directory C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64. in my case, they are cublas.lib;cuda.lib;cudadevrt.lib;cudart.lib;cudart_static.lib;cufft.lib;cufftw.lib;curand.lib;cusolver.lib;cusparse.lib;nppc.lib;nppial.lib;nppicc.lib;nppicom.lib;nppidei.lib;nppif.lib;nppig.lib;nppim.lib;nppist.lib;nppisu.lib;nppitc.lib;npps.lib;nvblas.lib;nvgraph.lib;nvml.lib;nvrtc.lib;OpenCL.lib; Add in Sources Files a file called \"test.cu\", right click it - Properties-General-Item Type: set as \"CUDA C/C++\". Copy the test code below to test.cu, run. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &quot;cuda_runtime.h&quot;#include &quot;device_launch_parameters.h&quot;#include &lt;stdio.h&gt;#include &lt;iostream&gt;int main() { int deviceCount; cudaGetDeviceCount(&amp;deviceCount); printf(&quot;%d device in total\\n&quot;, deviceCount); int dev; for (dev = 0; dev &lt; deviceCount; dev++) { int driver_version(0), runtime_version(0); cudaDeviceProp deviceProp; cudaGetDeviceProperties(&amp;deviceProp, dev); if (dev == 0) if (deviceProp.minor = 9999 &amp;&amp; deviceProp.major == 9999) printf(&quot;\\n&quot;); printf(&quot;Device %d: %s\\n&quot;, dev, deviceProp.name); cudaDriverGetVersion(&amp;driver_version); printf(&quot;CUDA driver version: %d.%d\\n&quot;, driver_version / 1000, (driver_version % 1000) / 10); cudaRuntimeGetVersion(&amp;runtime_version); printf(&quot;CUDA runtime version: %d.%d\\n&quot;, runtime_version / 1000, (runtime_version % 1000) / 10); printf(&quot;device computing capacity: %d.%d\\n&quot;, deviceProp.major, deviceProp.minor); printf(&quot;Total amount of Global Memory: %I64u bytes\\n&quot;, deviceProp.totalGlobalMem); printf(&quot;Number of SMs: %d\\n&quot;, deviceProp.multiProcessorCount); printf(&quot;Total amount of Constant Memory: %I64u bytes\\n&quot;, deviceProp.totalConstMem); printf(&quot;Total amount of Shared Memory per block: %I64u bytes\\n&quot;, deviceProp.sharedMemPerBlock); printf(&quot;Total number of registers available per block: %d\\n&quot;, deviceProp.regsPerBlock); printf(&quot;Warp size: %d\\n&quot;, deviceProp.warpSize); printf(&quot;Max number of threads per SM: %d\\n&quot;, deviceProp.maxThreadsPerMultiProcessor); printf(&quot;Max number of threads per block: %d\\n&quot;, deviceProp.maxThreadsPerBlock); printf(&quot;Max size of each dimension of a block: %d x %d x %d\\n&quot;, deviceProp.maxThreadsDim[0], deviceProp.maxThreadsDim[1], deviceProp.maxThreadsDim[2]); printf(&quot;Max size of each dimension of a grid: %d x %d x %d\\n&quot;, deviceProp.maxGridSize[0], deviceProp.maxGridSize[1], deviceProp.maxGridSize[2]); printf(&quot;Max memory pitch: %I64u bytes\\n&quot;, deviceProp.memPitch); printf(&quot;Max size of texture dimension: 1D=(%d) 2D=(%d x %d) 3D=(%d x %d x %d)\\n&quot;, deviceProp.maxTexture1D, deviceProp.maxTexture2D[0], deviceProp.maxTexture2D[1], deviceProp.maxTexture3D[0], deviceProp.maxTexture3D[1], deviceProp.maxTexture3D[2]); printf(&quot;Max size of layered texture: 1D=(%d) x %d 2D=(%d,%d) x %d\\n&quot;, deviceProp.maxTexture1DLayered[0], deviceProp.maxTexture1DLayered[1], deviceProp.maxTexture2DLayered[0], deviceProp.maxTexture2DLayered[1], deviceProp.maxTexture2DLayered[2]); printf(&quot;Texture alignmemt: %I64u bytes\\n&quot;, deviceProp.texturePitchAlignment); printf(&quot;Clock rate: %.2f GHz\\n&quot;, (double)deviceProp.clockRate * 1.0e-6f); printf(&quot;Memory Clock rate: %.0f MHz\\n&quot;, (double)deviceProp.memoryClockRate * 1.0e-3f); printf(&quot;Memory Bus Width: %d-bit\\n&quot;, deviceProp.memoryBusWidth); printf(&quot;L2 Cache Size: %d bytes\\n&quot;, deviceProp.l2CacheSize); } return 0;}","link":"/2021/12/27/CUDA10-2-VS2019-win10-configuration/"},{"title":"IPC","text":"Workflow {\"t\":\"root\",\"d\":0,\"v\":\"\",\"c\":[{\"t\":\"heading\",\"d\":1,\"p\":{\"lines\":[0,1]},\"v\":\"Testa\",\"c\":[{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[2,3]},\"v\":\"test1\"},{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[4,5]},\"v\":\"test2\"}]},{\"t\":\"heading\",\"d\":1,\"p\":{\"lines\":[6,7]},\"v\":\"Testb\",\"c\":[{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[8,9]},\"v\":\"test1\"},{\"t\":\"heading\",\"d\":2,\"p\":{\"lines\":[10,11]},\"v\":\"test2\"}]}],\"p\":{}} 1 介绍增量势能接触 (IPC) 求解器是为基于网格离散化的非线性体积弹性动力学问题而构建的，支持大的非线性变形、任意的隐式时间步长、摩擦、任意维数（点、曲线、曲面和体积）的边界、任意的空间离散精度。 The key element：the formulation of contact problem &amp;&amp; the customized numerial method to solve it. 1.1 贡献 一个基于【无符号距离函数(UDF)】的接触模型 barrier几乎处处C2、C1连续 → 可以使用快速收敛的Newton型无约束优化方法(customized Newton-based solver) barrier只影响很少一部分点(≈存在接触的点) → 接触力的施加高度局部化，只有很少一部分barrier需在优化过程中显式计算 contact-aware line search：保证了无穿透(collision-free)，augmented with CCD(由conservative-bound contact specific CFL-inspired filter加速) lagged dissipative potential：一个新的可变的摩擦力模型（带平滑化的静摩擦力） 一个仿真测试集的新benchmark 2 contact model - 接触模型focus：解”带接触的、非线性volumetric弹性体动力学模型“的数值时间积分问题。 问题等效为：在轨迹上最大化the extended-value action .（？？？） , where are external forces, are dissipative frictional forces. 为简化问题，假设：所有物体都被离散成 n 维的分段线性的element。 我们构建了admissibility的一个新定义，基于无符号距离函数（unsigned distance function, UDF）。最大的好处是可以像处理任意premitives一样的方式，处理任意维度物体之间的碰撞，”处理“ 即 ”构建精确的接触约束（exact contact constraints）“。 （*primitive指point, edge or triangle.） 定义 ”轨迹（trajectories） 为 intersection-free“ ：任意时间t，物体边界上任意两个不同的点p和q之间的距离满足d(p,q)&gt;0。 ，但optimization问题可能在开集上无解。所以我们定义 作为 的闭集。 unsigned distance the set of mesh primitives admissible定义一：a piecewise-linear trajectory starting in an intersection-free state is admissible, if for all times , the configuration satisfies constraints for all , where is the set of all non-adjacent (edge-edge) and non-incident (point-triangle) surface mesh primitive pairs. admissible定义二：A trajectory is admissible, if it is intersection-free, or there is an intersection-free trajectory arbitrarily close. 重要结论：观察到，如果没有intersection，任何primitives之间的距离都以点-三角形、边-边距离为下界。所以It is sufficient to enforce constraints continuously in time, for all , where contains all non-adjacent edge-edge pairs and non-incident point-triangle pairs in surface mesh. Time discretizationIncremental Potential (IP) for implicit Euler . 不带约束的最小化问题：牛顿迭代+line search→稳定收敛 . 带约束的最小化问题： 即无穿透. 目标：定义一种数值方法来逼近式(2)的解。 难点：如何s为离散曲面定义无穿透的数学表达式（即的定义），以及如何求解。 对于摩擦接触，引入lagged dissipative potential。 2.1 Trajactory Accuracies - 轨迹准确性定义：trajectories for which surfaces stay -separated （距离至少） 3 related workcomputational contact modeling 核心：几何的不相交约束 + 弹性体动量守恒的分辨率（?） 3.1 Constraints and Constraint Proxies - 约束 &amp; 约束代理因为需要计算admissibility，所以需要选择一种接触约束（contact constraints）的表达形式 不同类型的模型，有不同的表达形 volumetric模型：常用signed distance function (SDF)； mesh模型：选择不一，常成对地定义在相应的表面primitives之间（比如，点-三角形，边-边）； 现有方法 利用非线性代理函数以及它们的线性化形式，定义一个局部的有向距离的评估。此类方法包括 线性槽(gap)函数 由几何法向量计算的线性约束 有向体积约束 这些非线性代理(nonlinear proxies)存在问题：只是局部有效的，因此会引入 artificial ghost contact force (当受剪切力时) false positives (当旋转时) discontinuities (当穿越表面元素边界时) 同时，很多方法需要 进一步的线性化 以求解一个带约束的时间步长。 槽函数法 or “接触点和法向量”法：通过把 一个两两primitives之间的线性化的距离量 局部地映射到 一个固定的几何法向量上，来近似primitives之间的SDF。 存在问题： 迭代的成功率 与 网格表面的变化 敏感（highly varied results; largely dependent on the scene; highly sensitive to surface variations with well-known failure modes） fictitious domain法 3.2 Implicit Time Step Algorithms for Contact - 接触的隐式时间步长算法contact constraint proxy the solve for the implicit time step is the minimization of the contact-constraint IP 3.3 Friction - 摩擦Maximal Dissipation Principle (MDP) 3.4 Barrier Functions - 障碍函数3.5 总结现在的contact simulation的方法对每一个实例是很有效的，但是基本上都要很费劲地调参才能成功（即得到稳定、不交叉、plausible或可预测的结果）。而且很多调的参数都依赖于大量的数据，而不是基于物理。Towards一个直接的、”plug and play”的接触仿真框架，我们提出IPC，对于各种各样的网格分辨率、时间步长、物理条件、材料参数、大形变，我们都确认了IPC不需要条件算法的参数。 4 Primal Barrier Contact Mechanics \\begin{array}{lc} \\hline \\text { Algorithm } 1 \\text { Barrier Aware Projected Newton } \\\\ \\hline \\text { 01: procedure BarrierAwareProjectedNewton }\\left(x^{t}, \\boldsymbol{\\epsilon}\\right) \\\\ \\text { 02: } \\quad \\quad x \\leftarrow x^{t} \\\\ \\text { 03: } \\quad \\quad \\hat{C} \\leftarrow \\text { ComputeConstraintSet }(x, \\hat{d}) \\rightarrow Section\\ 4.6,6.1\\\\ \\text { 04: } \\quad \\quad E_{\\text {prev }} \\leftarrow B_{t}(x, \\hat{d}, \\hat{C}) \\\\ \\text { 05: } \\quad \\quad x_{\\text {prev }} \\leftarrow x \\\\ \\text { 06: } \\quad \\quad \\text {do } \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad\\quad \\quad \\quad \\quad \\quad \\quad \\quad \\triangleright \\text { Section 4.6,6.1} \\\\ \\text { 07: } \\quad \\quad \\quad \\quad H \\leftarrow \\operatorname{SPDProject}\\left(\\nabla_{x}^{2} B_{t}(x, \\hat{d}, \\hat{C})\\right) \\rightarrow Section\\ 4.3\\\\ \\text { 08: } \\quad \\quad \\quad \\quad p \\leftarrow-H^{-1} \\nabla_{x} B_{t}(x, \\hat{d}, \\hat{C}) \\\\ \\text { 09: } \\quad \\quad \\quad \\quad \\text{//CCD line search}: \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\triangleright \\text { Section 4.4}\\\\ \\text { 10: } \\quad \\quad \\quad \\quad \\alpha \\leftarrow \\min (1, \\text { StepSizeUpperBound }(x, p, \\hat{C})) \\\\ \\text { 11: } \\quad \\quad \\quad \\quad \\text {do } \\\\ \\text { 12: } \\quad \\quad \\quad \\quad \\quad \\quad x \\leftarrow x_{\\text {prev }}+\\alpha p \\\\ \\text { 13: } \\quad \\quad \\quad \\quad \\quad \\quad \\hat{C} \\leftarrow \\text { ComputeConstraintSet }(x, \\hat{d}) \\\\ \\text { 14: } \\quad \\quad \\quad \\quad \\quad \\quad \\alpha \\leftarrow \\alpha / 2 \\\\ \\text { 15: } \\quad \\quad \\quad \\quad \\text {while } B_{t}(x, \\hat{d}, \\hat{C})>E_{\\text {prev }} \\\\ \\text { 16: } \\quad \\quad \\quad \\quad E_{\\text {prev }} \\leftarrow B_{t}(x, \\hat{d}, \\hat{C}) \\\\ \\text { 17: } \\quad \\quad \\quad \\quad x_{\\text {prev }} \\leftarrow x \\\\ \\text { 18: } \\quad \\quad \\quad \\quad \\text {Update } \\kappa, \\text { BCs and equality constraints } \\quad \\triangleright \\text { Supplemental } \\\\ \\text { 19: } \\quad \\quad \\text { while } \\frac{1}{h}\\|p\\|_{\\infty}>\\epsilon_{d} \\\\ \\text { 20: } \\quad \\quad \\text { return } x \\\\ \\hline \\end{array}4.1 Barrier-augmented Incremental Potential - 带障碍函数的增量势to enforce for all , we construct a continuous barrier energy (局部的排斥力，只有将要碰撞时才有效) 定义 barrier augmented IP：. 4.2 Smoothly Clamped Barriers - 平滑截断的障碍函数需要clamp的原因：简单地计算energy会导致的复杂度，很多仿真方法只是简单地去掉距离较远的primitives之间的约束（认为它们不会碰撞），这种操作很危险，可能导致不稳定、错过可能的碰撞。我们设计平滑的barrier函数，从而在准确高效地计算所有约束的barrier energy的同时只需考察primitive pairs的一个小子集。 computational distance accuracy target 或 clamping thrshold (= in Section 2) barrier function b(d,\\hat{d})=\\left\\{\\begin{aligned}&-(d-\\hat{d})ln(d/\\hat{d}),&0 \\\\& 0,&d\\geq\\hat{d}\\end{aligned}\\right. culled constraint set 4.3 Newton-type Barrier Solver - 牛顿型障碍函数的求解器 projected Newton (PN) ：一种二阶无约束优化策略，用于最小化非线性非凸函数（且Hessian可能indefinite） barrier Hessian 的形式是 4.4 Intersection-aware Line Search (filter)灵感来源：inversion-aware line search filter[2] where our contact forces are given by barrier derivatives 注：barrier趋于无穷不能保证不相交，而是这里的Intersection-aware Line Search保证了IPC的不相交！ 4.5 IPC Solution Update4.6 Constraint Set Update and CCD Acceleration6 Distance Computation6.1 Combinational Distance Computationfor pair of primitives （*primitive指point, edge or triangle.） point-triangle distance . edge-edge distance . primitive-primitive diatance two constraints: , where and are and , or two endpoints of edges in edge-edge pair. single constraint: , where … no constraints: . 这样“无穿透”三个字就可以在任意情况下准确严谨地表达为： . 虽然我们的和其实都可以根据相对位置关系写成连续分段解析函数，我们对“无穿透”三个字的数学描述还是很昂贵的：a 可以取0到1之间无穷个实数，k 的个数则是物体表面点、边、三角形数量的二次方级别的！ 而IPC的解决方案，就是巧用连续碰撞检测(CCD)来对付a，并构造光滑的局部障碍函数来对 k 降维！ anyway 带约束的最小化问题： 即无穿透. 问题转化成无约束的最小化问题 . reference [1] Li - 2020 - IPC. [2] Smith - 2015 - Bijective parameterization with free boundaries. .markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}} const mindmaps = document.querySelectorAll('.markmap-svg'); for(let mindmap of mindmaps) { markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML)); }","link":"/2021/12/30/IPC/"},{"title":"Implicit Geometric Regularization","text":"I looked into the paper 'Implicit Geometric Regularization for Learning Shapes' and did a presentation on it.","link":"/2021/12/11/Implicit-Geometric-Regularization/"},{"title":"Material_Point_Method(MPM)","text":"MPM - Definition a hybrid Lagrangian/Eulerian discretization scheme for solid mechanics (MLS-2018-Hu) the generalization of Particle In Cell (PIC) and Fluid Implicit Particle Method (FLIP) to solid mechanics.(MPM course-2016-Jiang) MPM - Features (MPM course-2016-Jiang) combine Lagrangian material particles (points) with Eulerian Cartesian grids. no inherent need for Lagrangian connectivity. implicitly handle self-collision and fracture with the background Eulerian grid. Continuum Theory (MPM course-2016-Jiang) Continuum assumption can be made for almost all solids and liquids, including deformable (elastic and plastic)objects, muscle, flesh, cloth, hair, liquid, smoke, gas, granular materials (sand, snow, mud, soil, etc.). A continuum body defines quantities such as density, velocity and force as continuous functions of position. The main focus of continuum kinematics/motion is the deformation, either locally or globally in different coordinate systems of interests. Luckily in most cases, we can describe kinematics without introducing the meaning of force, stress or even mass.","link":"/2021/12/06/Material-Point-Method-MPM/"},{"title":"NeRF","text":"NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis NeRF repository contributions neural radiance fields network or ，where only relies on . volume rendering color , where transmittance , ray . radiance field: the color radiating from point in direction . stratified sampling for integral estimation evenly partition into bins, then sample uniformly at random in each bin. color , where , . 注意：采样后变成了（用到了exp(x)-&gt;x+1(x-&gt;0)的近似）；在表达式中，采样值乘区间长度代替了积分。 问题：这里能用Monte-Carol估计积分吗?","link":"/2021/11/30/NeRF/"},{"title":"Volume_Rendering","text":"my Thoughts volume rendering 优点：统一 transparent 和 opaque 物体的渲染方法，如毛发、烟雾等； 缺点：计算量远大于surface rendering；存储量大？ 通过opacity来确认occlusion in NeRF-2020 color , where transmittance , ray . radiance field 指 stratified sampling for integral estimation: do random uniform sample in each even partition . 即 , is the number of partitions. color , where , . 注：采样后换成了，利用； 注：在表达式中，采样值区间长度之积代替了积分。 in Volume Rendering of Neural Implicit Surfaces-2021-Yariv paper page \"In essence, volume rendering is all about approximating the integrated light radiance along this ray reaching the camera.\" \"体渲染的本质：估计积分\" transparency (same as NeRF) opacity , , , and it is monotonic increasing. weight is a PDF (Probability Density Function) color , where is radiance field 注：这里的 相当于NeRF里的 ，只是增加了对边界法向量 的依赖。 \"NeRF is heavily affected by the sampled point during intensity calculation.\" 采样方法的问题： NeRF的 \"random uniform sample\" 会造成 artifacts； 若改成 \"fixed uniform sample\" 会造成另一种 artifacts； in Neural Volumes: Learning Dynamic Renderable Volumes from Images-2019-Lombardi paper page （*本文最早把volume rendering用于novel view synthesis） from Section 6.1 Semi-Transparent Volume Rendering \"If the accumulated opacity reaches 1 (for example, when the ray traverses an opaque region), then no further color can be accumulated on the ray\"","link":"/2021/11/29/Volume-Rendering/"},{"title":"approaches & methods","text":"Descent Methods Gradient Descent: . Newton's method: . Quasi-Newton methods: Nonlinear Conjugate Gradient(CG): , . Numerical Procedure Designs Position Based Dynamics (PBD): build a projection for every constraint Projective Dynamics: uses the projection in energy corotational FEM method: can be seen as as projective dynamics with rotation as projection Iterative Linear Solvers Gauss-Seidel: Jacobi: Conjugate gradients: acceleration methods Chebyshev Semi-Iterative Method: Nesterov's Method:","link":"/2021/12/20/approaches/"},{"title":"cloth simulation","text":"Method 1: Newton's Method + Jacobi Method with Chebyshev Acceleration Newton's method is also called backward Euler or implicit Euler Method 2: Position Based Dynamics + a Jacobi Approach To avoid bias of Gauss-Seidel Approach, we adopt Jacobi Approach. notes on PBD: 'Position based' is relative to 'force based'. PBD updates position first, while force-based methods update velocity first. Update of position is based on projection (a map from to ). See 'A Survey on Position Based Dynamics, 2017' for more detail. See '【深入浅出 Nvidia FleX】(1) Position Based Dynamics' for a concise introduction. Reference [1] Huamin Wang's GAMES103 course","link":"/2021/12/12/cloth-simulation/"},{"title":"collision simulation","text":"Collision Detection Pipeline Broad-Phase Collision Culling Spatial Hashing (SH) Easy to implement GPU friendly Needs to recompute after updating objects Bounding Volume Hierarchy (BVH) More involved Not GPU friendly To update BVH, just update bounding volumes Pairs edge-triangle pair, or vertex-triangle and edge-edge pairs Narrow-Phase Collision Test Discrete Collision Detect (DCD) issues with DCD Continuous Collision Detect (CCD) issues with CCD Floating-point errors, especially due to root finding of a cubic equation Buffering epsilons, but that causes false positives. Gaming GPUs often use single floating-point precision. Computational costs: more expensive than DCD. Some argue that broad-phase collision culling is the bottleneck. Difficulty in implementation. Collision Response Two methods: Interior Point Method &amp;&amp; Impact Zone Optimization. Interior Point Method Log-Barrier implementation Impact Zone Optimization We can also turning this into an unconstraint optimization problem: Augmented Lagrangian pros &amp; cons Reference [1] Huamin Wang's GAMES103 course, 09_collision [2] Incremental Potential Contact-2020-Li","link":"/2022/01/05/collision-simulation/"},{"title":"elastic simulation","text":"Deformation undeformed/reference configuration deformed configuration deformation map deformation gradiant or ( is the Jacobian matrix of ) Strain &amp; Hyperelasticity strain energy note: for hyperelastic materials, only depends on (or the initial and final configurations and ) and not on the deformation path over time (or equivalently, the elastic forces of hyperelastic materials are conservative). energy density measures the strain energy per unit undeformed volume on an infinitesiml domain around the mateiral point using first-order Taylor expansion thus, is a function of alone, i.e. . Force &amp; Traction force density aggragate force on a finite region is . traction (surface force density) aggragate force on a finite boundary region is . Stress 1st Piola-Kirchhoff stress (a 3*3 matrix or tensor, short as PK1 stress) where is outward normalunit normal to the boundary in the undeformed configuration. or for hyperelastic materials, note Much literature define and because and are seen as external. However, such definitions are only true when the body is in an equilibrium configuration. We retain our original definition above and denote external force and traction as and . Strain Green strain (tensor) if we do polar decomposition deformation gradient as , then small/infinitesimal strain (tensor, a linear approximation of ) 🐇 Linear Elasticity . where . . 🐇 Neo-Hookean Elasticity . where (the same as linear elasticity), is dimension. . the most often used elasticity model in CG. 🐇 St. Venant-Kirchhoff Elasticity Replacing strain in Linear Elasticity with , we get . . in energy density , is against stretch, is against volume change. rotational invariant, but with quartic complexity. Elasticity Modeling Procedures Given , for each tetrahedron (the simplest finite element in 3D, often used in CG), pre-compute (the volume) and (the inverse of the reference edge matrix). Update by Newton's (, ) to get , then calculate . Now we can get gradient , stress (according to its formula in each elasticity model). Finally, calculate force and Update by Newton's. 🐇 Corotated Linear Elasticity Replacing strain in Linear Elasticity with (by polar decomposition ), we get where is from singular value decomposition (SVD) . rotational invariant, but the polar decomposition is computationally costly. Rotationally Invariant &amp; Isotropic rotationally invariant: if and only if . isotropic: if and only if . Using SVD , we conclude that rotationally invariant and isotropic materials satisfy . Invariants right Cauchy Green tensor . Using SVD , with . . invariants . . . reference [1] SIGGRAPH 2012 Course \"FEM Simulation of 3D Deformable Solids: A practitioner's guide to theory, discretization and model reduction\"","link":"/2021/12/15/elastic-simulation/"},{"title":"linear solver","text":"Problem Solvers Iterators Gauss-Seidel iteration Jacobi Jacobi v.s. Gauss-Seidel [2] Conjugate gradients Reference [1] Huamin Wang's GAMES103 course and Yuanming Hu's GAMES201 course [2] Bouaziz - 2016 - Projective dynamics: Fusing constraint projections for fast simulation.","link":"/2021/12/13/linear-solver/"},{"title":"multigrid","text":"Model Problem One-dimensional boundary value problem . . grid . 设和，. Approximate using Taylor series, we get . The problem turns into . . Let 和. 矩阵形式，其中是N-1阶对称正定矩阵， . 解法： Direct 高斯消元（Gaussian elimination） 因式分解（Factorization） Iterative Jacobi Gauss-Seidel Conjugate Gradient Iterative Methods for Linear Systems Consider and let be an approximation to . error , with norms , . residual , with norms , . residual equation . residual correction . Relaxation Schemes Consider the 1D model problem . Jacobi Relaxation . Let where is diagonal and and are the strictly lower and upper parts of . Then becomes Let , subtracting from , we get . Weighted Jacobi Relaxation . . Gauss-Seidel Relaxation . , as well, then . Let Red-Black Gauss-Seidel Relaxation even (red) points: . odd (black) points: . note: Jacobi and Red-Black Gauss-Seidel are both suitable for parallel computation. Analysis of stationary iterations Let . The exact solution is unchanged by the iteration, i.e., . . . Fundamentals of Fourier Fourier modes , component , mode/frequency . Fundamentals of iteration convergence factor . is convergent ( as ) if and only if . asymptotic(渐近线的) convegence rate . *note: the number of iterations needed to reduce the error by : . Convergence of Jacobi &amp; weighted Jacobi on Au=0 relaxation matrix , eigenvalues . (let ) , where . . and have the same eigenvectors , with its component , , . meaning of eigenvalues Expand the initial error with eigenvectors: After iterations, . The mode of the error is reduced by at each iteration. choice of weight Note that if then for （即所有频率都会衰减） 但long waves()在任何下都几乎不衰减，如. Choose a that best dump the short waves(): let . smoothing factor For , with , experiment Jacobi method on with . Number of iterations required to reduce to . Initial guess: . Important conclusion(*) Many relaxation shemes have the smoothing property, where oscillatory modes of the error are eliminated effectively, but smooth modes are damped very slowly. or say, Relaxation is most effective on oscillatory error modes. Convergence of Gauss-Seidel on Au=0 . . . and have different eigenvectors, Gauss-Seidel mixes the modes of . Multigrid ideas fine grid(fg) : separated into with grid length . coarse grid(cg) : separated into with grid length . Nested Iteration use cg compute an improved initial guess for fg relxation. Relaxation on cg is much cheaper (1/2 in 1D, 1/4 in 2D, 1/8 in 3D). Relaxation on cg has a marginally better convergence rate, e.g. instead of . procedures: ... Relax on on to obtain intial guess . Relax on on to obtain intial guess . Relax on on to obtain the final solution. But, what is on , , ...? What if the error still has smooth components when we get to the fine grid ? Coarse-Grid Correction use error relaxed on cg to correct the approximation . Smooth error is more oscillatory in cg, thus relaxation is more effective. (See conclusion(*)). Use the residual equation to relax on the error . But, what does it mean to relax on on ? How to relax on and what initial guess should be used? How do we transfer the error estimate from back to ? Intergrid transfer operators For , the mode is preserved on cg. (the superscript indicates the grids on which the vectors are defined). For , the mode on fg becomes mode on cg. (called aliasing) . Prolongation operator Considering the 1D case, , where , for . We may regard as a linear operator from to . e.g. for , has full rank, and thus null space is empty set （即无解）. If is smooth, approximate very well. If is oscillatory, approximate not well. Therefore, Nested Iteration is most effective when the error is smooth. Restriction operator Considering the 1D case, restriction by injection: , where . restriction by full-weighting: , where . In the discussion that follows, we use full weighting as a restriction operator. We may regard as a linear operator from to . e.g. for , has rank , and thus . Relation between prolongation and restriction A commonly used and highly useful requirement is , for in . The fact that the interpolation operator and the full weighting operator are transposes of each other up to a constant is called a variational property and will soon be of importance. Two-Grid Correction Scheme : Relax times on on with initial guess . Compute residual: . Restrict (transfer to cg): . Relax several times on on with initial guess . Prolongate/Interpolate (transfer to fg): . Correct the approximation . Relax times on on with intial guess . What is ? ? How to solve the cg residual equation? Recursion! Schemes for solving residual equation V-Cycle Scheme . Relax times on with a given initial guess . If , then go to step 4. Else , -- , -- initial guess . Correct . Relax times on with initial guess . The V-cycle is just one of a family of multigrid cycling schemes. The entire family is called the µ-cycle method and is defined recursively by the following. -Cycle Scheme µ. Relax ν1 times on Ahuh = fh with a given initial guess vh. If Ωh = coarsest grid, then go to step 4. Else f2h ← I2h h (fh - Ahvh), v2h ← 0, v2h ← Mµ2h(v2h,f2h) µ times. Correct . Relax ν2 times on Ahuh = fh with initial guess vh. In practice, only µ = 1 (which gives the V-cycle) and µ = 2 are used.","link":"/2022/01/13/multigrid/"},{"title":"my FEM elastic simulation with Unity","text":"I finished Huamin Wang's GAMES103 homework 3. results: St. Venant Kirchhoff Model: Neo-Hookean Model + SVD (the 'principal stretches' or 'matrix invariants' method) A late Merry Christmas to myself ! ❄🎄🎅🔥😊 2021.12.26","link":"/2021/12/26/my-FEM-elastic-simulation-with-Unity/"},{"title":"rigid body collision","text":"Method: Shape Matching Basic Idea: first handle collision and friction of vertices independetnly, then enforce constraint to restore regidity. Advantages: Easy to implement and compatible with other nodal systems, i.e., cloth and soft bodies. Disadvantages: Difficult to strictly enforce friction and other goals. (The rigidification process will destroy them.) Suggestion: More suitable when the friction accuracy is less important, i.e., buttons on clothes. Reference Huamin Wang's GAMES103 course","link":"/2021/12/11/rigid-body-collision/"},{"title":"time integration","text":"integrators forward Euler (explicit Euler): semi-implicit Euler (symplectic) backward Euler (implicit Euler) or Newton's method: (see one of the applications of this method here) comparison: explict vs. implict explict (forward Euler, symplectic Euler, RK, ... ) easy to implement, future only relies on past. 😟easy to explode: , especially for stiff materials. implicit (backward Euler, middle-point, ... ) future relies on past &amp; future, need to solve equations. support larger time step (robustness, thus the mainstream) 😟numerical damping &amp; locking. unifying CFL condition , where is CFL number, is time step, is length interval (e.g. particle radius, grid size), is maximum (velocity) Typical : SPH: MPM: FLIP fluid (smoke): reference [1] Yuanming Hu - ppt in the course GAMES201. [2] Bouaziz - 2016 - Projective dynamics: Fusing constraint projections for fast simulation.","link":"/2021/12/13/time-integration/"},{"title":"Projective Dynamics","text":"h Position Based Dynamics (PBD): build a projection for every constraint Projective Dynamics: uses the projection in energy Projective Dynamics 主要思想：通过定义辅助变量，把一个大规模非线性非凸优化问题，拆解成global大规模二次凸优化问题+local多个小规模非线性非凸优化问题，在global和local之间轮番迭代求解。 应用范围：弹簧质点模型[4]、有限元模型[1]、 分类：an implicit integration solver continuum mechanics (physics-based) + PBD 注：连续体力学(continuum mechanics): “弹性体的形变” 由 “弹性势能(elastic potential energy)” 来量化。问题在于：弹性力往往非线性，使运动方程的时间积分变得复杂。 引入连续体动力学的思路：continuous deformation energies -&gt; a specific set of constraints -&gt; potentials: a convex quadratic measure from a constraint -&gt; local/global optimizations use alternating local/global optimization, generalizing efficient implicit time integration of mass-spring system (Liu-2013-Fast simulation of mass-spring system) local step: project every element onto the constraint manifold (用投影法，使每个元素满足约束) global step: 找到各个约束的映射的折中方案，同时考虑全局影响，如惯性和外力。 +Advantages generally, 。 over PBD: physices-based over Newton-based: Newton's needs line search and safeguard against singular or indefinite Hessians to guarantee robustness. Local-Global Iterations PD的精髓：alternating (between local &amp; global) solver 解决的问题：Newton法对非线性非凸函数的优化太慢 以上问题的原因： 每一次迭代都要计算非线性弹性势能函数的Hessian （因为弹性势能依赖于顶点位置）； 因为非凸，所以算出来的Hessian 可能indefinite；（若不正定，Newton法可能给出一个上升的方向，即指想局部极大值点）所以要么选择正定化，要么选择其他方案； Local projection compute the target positions of a subgroup of vertices under the i-th constraint. , . , where is selection matrix for the constraints . and are constant matrice, often Laplacian-like（？）, for a better distance measure. sets the target position of intersecting vertex as it closest projection on the collision plane. nonlinear, but each constraint involves only a few DOFs thus can be parallelized (GPU-friendly). Global solve a standard linear solve for where is the weight of each constraint PD treats collision as a constraint. During simulation, it is refactorized and solved at each L-G ieration as collision constraints vary. reference [1] Bouaziz - 2016 - Projective dynamics: Fusing constraint projections for fast simulation. [2] Intersection-free Deformation on GPU. [3] GAMESWebinar2017-16期(2)-刘天添. [4] Liu - 2013 - Fast Simulation of Mass-Spring Systems.","link":"/2022/02/02/Projective-Dynamics/"},{"title":"Numerical Optimization","text":"To catch up with common methods on numerical optimization Wolfe conditions = sufficient decrease + curvature condition sufficient decrease: $f(x_k+k p_k) f(x_k)+c{1} _k f_k^T p_k $. curvature condition: . with . A step length may satisfy the Wolfe conditions without being particularly close to a minimizer of , as we show in Figure 3.5. We can, however, modify the curvature condition to force to lie in at least a broad neighborhood of a local minimizer or stationary point of . strong Wolfe conditions . . with . The only difference is that we no long allow to be too positive. Backtracking 步长从大到小搜索，找到符合sufficient decrease条件的最大步长，免去了curvature条件。 Algorithm 3.1 (Backtracking Line Search). ​ Choose ; ​ Set ; ​ repeat until ​ ; ​ end (repeat) ​ Terminate with . where for some constant","link":"/2022/02/05/Numerical-Optimization/"}],"tags":[{"name":"Newton","slug":"Newton","link":"/tags/Newton/"},{"name":"gradient","slug":"gradient","link":"/tags/gradient/"},{"name":"iterative","slug":"iterative","link":"/tags/iterative/"},{"name":"tutorial","slug":"tutorial","link":"/tags/tutorial/"},{"name":"paper","slug":"paper","link":"/tags/paper/"},{"name":"2020","slug":"2020","link":"/tags/2020/"},{"name":"siggraph","slug":"siggraph","link":"/tags/siggraph/"},{"name":"presentation","slug":"presentation","link":"/tags/presentation/"},{"name":"elastic","slug":"elastic","link":"/tags/elastic/"},{"name":"simulation","slug":"simulation","link":"/tags/simulation/"},{"name":"method","slug":"method","link":"/tags/method/"},{"name":"mpm","slug":"mpm","link":"/tags/mpm/"},{"name":"ECCV","slug":"ECCV","link":"/tags/ECCV/"},{"name":"rendering","slug":"rendering","link":"/tags/rendering/"},{"name":"neural","slug":"neural","link":"/tags/neural/"},{"name":"sum-up","slug":"sum-up","link":"/tags/sum-up/"},{"name":"cloth","slug":"cloth","link":"/tags/cloth/"},{"name":"PBD","slug":"PBD","link":"/tags/PBD/"},{"name":"Jacobi","slug":"Jacobi","link":"/tags/Jacobi/"},{"name":"Chebyshev","slug":"Chebyshev","link":"/tags/Chebyshev/"},{"name":"Gauss-Seidel","slug":"Gauss-Seidel","link":"/tags/Gauss-Seidel/"},{"name":"collision","slug":"collision","link":"/tags/collision/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"rigid","slug":"rigid","link":"/tags/rigid/"},{"name":"implicit","slug":"implicit","link":"/tags/implicit/"},{"name":"Lagrangian","slug":"Lagrangian","link":"/tags/Lagrangian/"},{"name":"CCD","slug":"CCD","link":"/tags/CCD/"},{"name":"DCD","slug":"DCD","link":"/tags/DCD/"},{"name":"BVH","slug":"BVH","link":"/tags/BVH/"},{"name":"SH","slug":"SH","link":"/tags/SH/"},{"name":"Interior Point Method","slug":"Interior-Point-Method","link":"/tags/Interior-Point-Method/"},{"name":"Impact Zone Optimization","slug":"Impact-Zone-Optimization","link":"/tags/Impact-Zone-Optimization/"},{"name":"optimization","slug":"optimization","link":"/tags/optimization/"},{"name":"Projective Dynamics","slug":"Projective-Dynamics","link":"/tags/Projective-Dynamics/"}],"categories":[]}