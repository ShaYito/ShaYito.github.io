{"pages":[{"title":"about","text":"A senior undergraduate student fascinated by and dedicated to computer graphics. Interests computer graphics, simulation and physics-based animation, shape reconstrution, physics-based rendering Experiences Research Project: Precise Calibration and Modeling of Piezo-resistive Textile 2020.3-2021.9 Advisor: Prof. Jingyuan Cheng, School of Computer Science and Technology, USTC ◦ Realized a mathematical model to predict the nonlinear behavior of piezoresistive textile ◦ Built a finite-element physical model of the textile Education Bachelor of Engineering in Electronic Science and Technology at University of Science and Technology of China, 2018-2022 Skills ◦ Python (4000 lines, including Taichi) ◦ C++ (3000 lines, including OpenGL) ◦ C# (1200 lines, for Unity) ◦ MATLAB (500 lines) ◦ COMSOL (finite-element simulation, on Structural Mechanics and Electromagnetics) ◦ Cinema 4D (created animations for fun) Contact e-mail: shayito_@outlook.com","link":"/about/"},{"title":"links","text":"Useful Links GAMES (Graphics And Mixed Environment Seminar) Siggraph paper collection Thanks to The author of this hexo theme A great blog framework: hexo","link":"/links/"},{"title":"tags","text":"","link":"/tags/"}],"posts":[{"title":"Descent Optimization","text":"Algorithm Initialize ; for do ​ Calculate the descent direction ; ​ Adjust the step length ; ​ ; ​ ; return ; Descent Methods As long as descent direction satisfies , it is a possible descent direction. method descent direction note advantage disadvantage Gradient Descent . can be viewed as updating by force; simple; linear convergence rate; similar to explicit time integration, thus step leangth must be small; Newton's method , is the Hessian matrix of . note: not always descending, unless is positive definite. solve linear equation every iteration; quadratic convergence, the fastest; computationally expensive, not real-time; cannot be easily parallelized on GPU; Quasi-Newton methods approximate the Hessian matrix or its inverse, e.g., BFGS, L-BFGS. it's sequential by nature; less cost per iteration than Newton's; difficult to run on GPU, unless subject to box constraint; Nonlinear Conjugate Gradient(CG) where . generalization of Conjugate Gradient; highely similar to L-BFGS with ; much more friendly with GPU acceleration than quasi-Newton; still require multiple dot product operations, which restrict its performance on the GPU; total cost = per interation cost * number of iterations Reference [1] Parallel Iterative Solvers for Real-time Elastic Deformations - course notes. [2] Huamin Wang's GAMES103 course","link":"/2021/12/23/Descent-Optimization/"},{"title":"CUDA10.2+VS2019+win10 configuration","text":"Create a new Empty Project in VS2019, set \"Solution Platforms\" as \"x64\". Right click &lt;Your Project Name&gt;-Build Dependencies-Build Customizations, check CUDA xxxx Tools-Options-Projects and Solutions-VC++ Project Settings-Extensions To Include: add \".cu\". Right click &lt;Your Project Name&gt;-Properties, make sure Configuration above is always \"All Configurations\" &amp; \"x64\". On this page, go toVC++ Directories in Include Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\include; in Library Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64; go to Linker-General in Additional Library Directories, add C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64; go to Linker-Input in Additional Dependencies, add files inside directory C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.2\\lib\\x64. in my case, they are cublas.lib;cuda.lib;cudadevrt.lib;cudart.lib;cudart_static.lib;cufft.lib;cufftw.lib;curand.lib;cusolver.lib;cusparse.lib;nppc.lib;nppial.lib;nppicc.lib;nppicom.lib;nppidei.lib;nppif.lib;nppig.lib;nppim.lib;nppist.lib;nppisu.lib;nppitc.lib;npps.lib;nvblas.lib;nvgraph.lib;nvml.lib;nvrtc.lib;OpenCL.lib; Add in Sources Files a file called \"test.cu\", right click it - Properties-General-Item Type: set as \"CUDA C/C++\". Copy the test code below to test.cu, run. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &quot;cuda_runtime.h&quot;#include &quot;device_launch_parameters.h&quot;#include &lt;stdio.h&gt;#include &lt;iostream&gt;int main() { int deviceCount; cudaGetDeviceCount(&amp;deviceCount); printf(&quot;%d device in total\\n&quot;, deviceCount); int dev; for (dev = 0; dev &lt; deviceCount; dev++) { int driver_version(0), runtime_version(0); cudaDeviceProp deviceProp; cudaGetDeviceProperties(&amp;deviceProp, dev); if (dev == 0) if (deviceProp.minor = 9999 &amp;&amp; deviceProp.major == 9999) printf(&quot;\\n&quot;); printf(&quot;Device %d: %s\\n&quot;, dev, deviceProp.name); cudaDriverGetVersion(&amp;driver_version); printf(&quot;CUDA driver version: %d.%d\\n&quot;, driver_version / 1000, (driver_version % 1000) / 10); cudaRuntimeGetVersion(&amp;runtime_version); printf(&quot;CUDA runtime version: %d.%d\\n&quot;, runtime_version / 1000, (runtime_version % 1000) / 10); printf(&quot;device computing capacity: %d.%d\\n&quot;, deviceProp.major, deviceProp.minor); printf(&quot;Total amount of Global Memory: %I64u bytes\\n&quot;, deviceProp.totalGlobalMem); printf(&quot;Number of SMs: %d\\n&quot;, deviceProp.multiProcessorCount); printf(&quot;Total amount of Constant Memory: %I64u bytes\\n&quot;, deviceProp.totalConstMem); printf(&quot;Total amount of Shared Memory per block: %I64u bytes\\n&quot;, deviceProp.sharedMemPerBlock); printf(&quot;Total number of registers available per block: %d\\n&quot;, deviceProp.regsPerBlock); printf(&quot;Warp size: %d\\n&quot;, deviceProp.warpSize); printf(&quot;Max number of threads per SM: %d\\n&quot;, deviceProp.maxThreadsPerMultiProcessor); printf(&quot;Max number of threads per block: %d\\n&quot;, deviceProp.maxThreadsPerBlock); printf(&quot;Max size of each dimension of a block: %d x %d x %d\\n&quot;, deviceProp.maxThreadsDim[0], deviceProp.maxThreadsDim[1], deviceProp.maxThreadsDim[2]); printf(&quot;Max size of each dimension of a grid: %d x %d x %d\\n&quot;, deviceProp.maxGridSize[0], deviceProp.maxGridSize[1], deviceProp.maxGridSize[2]); printf(&quot;Max memory pitch: %I64u bytes\\n&quot;, deviceProp.memPitch); printf(&quot;Max size of texture dimension: 1D=(%d) 2D=(%d x %d) 3D=(%d x %d x %d)\\n&quot;, deviceProp.maxTexture1D, deviceProp.maxTexture2D[0], deviceProp.maxTexture2D[1], deviceProp.maxTexture3D[0], deviceProp.maxTexture3D[1], deviceProp.maxTexture3D[2]); printf(&quot;Max size of layered texture: 1D=(%d) x %d 2D=(%d,%d) x %d\\n&quot;, deviceProp.maxTexture1DLayered[0], deviceProp.maxTexture1DLayered[1], deviceProp.maxTexture2DLayered[0], deviceProp.maxTexture2DLayered[1], deviceProp.maxTexture2DLayered[2]); printf(&quot;Texture alignmemt: %I64u bytes\\n&quot;, deviceProp.texturePitchAlignment); printf(&quot;Clock rate: %.2f GHz\\n&quot;, (double)deviceProp.clockRate * 1.0e-6f); printf(&quot;Memory Clock rate: %.0f MHz\\n&quot;, (double)deviceProp.memoryClockRate * 1.0e-3f); printf(&quot;Memory Bus Width: %d-bit\\n&quot;, deviceProp.memoryBusWidth); printf(&quot;L2 Cache Size: %d bytes\\n&quot;, deviceProp.l2CacheSize); } return 0;}","link":"/2021/12/27/CUDA10-2-VS2019-win10-configuration/"},{"title":"Material_Point_Method(MPM)","text":"MPM - Definition a hybrid Lagrangian/Eulerian discretization scheme for solid mechanics (MLS-2018-Hu) the generalization of Particle In Cell (PIC) and Fluid Implicit Particle Method (FLIP) to solid mechanics.(MPM course-2016-Jiang) MPM - Features (MPM course-2016-Jiang) combine Lagrangian material particles (points) with Eulerian Cartesian grids. no inherent need for Lagrangian connectivity. implicitly handle self-collision and fracture with the background Eulerian grid. Continuum Theory (MPM course-2016-Jiang) Continuum assumption can be made for almost all solids and liquids, including deformable (elastic and plastic)objects, muscle, flesh, cloth, hair, liquid, smoke, gas, granular materials (sand, snow, mud, soil, etc.). A continuum body defines quantities such as density, velocity and force as continuous functions of position. The main focus of continuum kinematics/motion is the deformation, either locally or globally in different coordinate systems of interests. Luckily in most cases, we can describe kinematics without introducing the meaning of force, stress or even mass.","link":"/2021/12/06/Material-Point-Method-MPM/"},{"title":"NeRF","text":"NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis NeRF repository contributions neural radiance fields network or ，where only relies on . volume rendering color , where transmittance , ray . radiance field: the color radiating from point in direction . stratified sampling for integral estimation evenly partition into bins, then sample uniformly at random in each bin. color , where , . 注意：采样后变成了（用到了exp(x)-&gt;x+1(x-&gt;0)的近似）；在表达式中，采样值乘区间长度代替了积分。 问题：这里能用Monte-Carol估计积分吗?","link":"/2021/11/30/NeRF/"},{"title":"Volume_Rendering","text":"my Thoughts volume rendering 优点：统一 transparent 和 opaque 物体的渲染方法，如毛发、烟雾等； 缺点：计算量远大于surface rendering；存储量大？ 通过opacity来确认occlusion in NeRF-2020 color , where transmittance , ray . radiance field 指 stratified sampling for integral estimation: do random uniform sample in each even partition . 即 , is the number of partitions. color , where , . 注：采样后换成了，利用； 注：在表达式中，采样值区间长度之积代替了积分。 in Volume Rendering of Neural Implicit Surfaces-2021-Yariv paper page \"In essence, volume rendering is all about approximating the integrated light radiance along this ray reaching the camera.\" \"体渲染的本质：估计积分\" transparency (same as NeRF) opacity , , , and it is monotonic increasing. weight is a PDF (Probability Density Function) color , where is radiance field 注：这里的 相当于NeRF里的 ，只是增加了对边界法向量 的依赖。 \"NeRF is heavily affected by the sampled point during intensity calculation.\" 采样方法的问题： NeRF的 \"random uniform sample\" 会造成 artifacts； 若改成 \"fixed uniform sample\" 会造成另一种 artifacts； in Neural Volumes: Learning Dynamic Renderable Volumes from Images-2019-Lombardi paper page （*本文最早把volume rendering用于novel view synthesis） from Section 6.1 Semi-Transparent Volume Rendering \"If the accumulated opacity reaches 1 (for example, when the ray traverses an opaque region), then no further color can be accumulated on the ray\"","link":"/2021/11/29/Volume-Rendering/"},{"title":"approaches & methods","text":"Descent Methods Gradient Descent: . Newton's method: . Quasi-Newton methods: Nonlinear Conjugate Gradient(CG): , . Workflow Designs Position Based Dynamics (PBD): build a projection for every constraint Projective Dynamics: uses the projection to in energy corotational FEM method: can be seen as as projective dynamics with rotation as projection Iterative Linear Solvers Gauss-Seidel: Jacobi: Conjugate gradients: acceleration methods Chebyshev Semi-Iterative Method: Nesterov's Method:","link":"/2021/12/20/approaches/"},{"title":"cloth simulation","text":"Method 1: Newton's Method + Jacobi Method with Chebyshev Acceleration Newton's method is also called backward Euler or implicit Euler Method 2: Position Based Dynamics + a Jacobi Approach To avoid bias of Gauss-Seidel Approach, we adopt Jacobi Approach. notes on PBD: 'Position based' is relative to 'force based'. PBD updates position first, while force-based methods update velocity first. Update of position is based on projection (a map from to ). See 'A Survey on Position Based Dynamics, 2017' for more detail. See '【深入浅出 Nvidia FleX】(1) Position Based Dynamics' for a concise introduction. Reference [1] Huamin Wang's GAMES103 course","link":"/2021/12/12/cloth-simulation/"},{"title":"Implicit Geometric Regularization","text":"I looked into the paper 'Implicit Geometric Regularization for Learning Shapes' and did a presentation on it.","link":"/2021/12/11/Implicit-Geometric-Regularization/"},{"title":"collision simulation","text":"Method Elasticity Skinning-2011-McAdams Technical notes on equations of corotational elasticity","link":"/2021/12/07/collision-simulation/"},{"title":"elastic simulation","text":"Deformation undeformed/reference configuration deformed configuration deformation map deformation gradiant or ( is the Jacobian matrix of ) Strain &amp; Hyperelasticity strain energy note: for hyperelastic materials, only depends on (or the initial and final configurations and ) and not on the deformation path over time (or equivalently, the elastic forces of hyperelastic materials are conservative). energy density measures the strain energy per unit undeformed volume on an infinitesiml domain around the mateiral point using first-order Taylor expansion thus, is a function of alone, i.e. . Force &amp; Traction force density aggragate force on a finite region is . traction (surface force density) aggragate force on a finite boundary region is . Stress 1st Piola-Kirchhoff stress (a 3*3 matrix or tensor, short as PK1 stress) where is outward normalunit normal to the boundary in the undeformed configuration. or for hyperelastic materials, note Much literature define and because and are seen as external. However, such definitions are only true when the body is in an equilibrium configuration. We retain our original definition above and denote external force and traction as and . Strain Green strain (tensor) if we do polar decomposition deformation gradient as , then small/infinitesimal strain (tensor, a linear approximation of ) 🐇 Linear Elasticity . where . . 🐇 Neo-Hookean Elasticity . where (the same as linear elasticity), is dimension. . the most often used elasticity model in CG. 🐇 St. Venant-Kirchhoff Elasticity Replacing strain in Linear Elasticity with , we get . . in energy density , is against stretch, is against volume change. rotational invariant, but with quartic complexity. Elasticity Modeling Procedures Given , for each tetrahedron (the simplest finite element in 3D, often used in CG), pre-compute (the volume) and (the inverse of the reference edge matrix). Update by Newton's (, ) to get , then calculate . Now we can get gradient , stress (according to its formula in each elasticity model). Finally, calculate force and Update by Newton's. 🐇 Corotated Linear Elasticity Replacing strain in Linear Elasticity with (by polar decomposition ), we get where is from singular value decomposition (SVD) . rotational invariant, but the polar decomposition is computationally costly. Rotationally Invariant &amp; Isotropic rotationally invariant: if and only if . isotropic: if and only if . Using SVD , we conclude that rotationally invariant and isotropic materials satisfy . Invariants right Cauchy Green tensor . Using SVD , with . . invariants . . . reference [1] SIGGRAPH 2012 Course \"FEM Simulation of 3D Deformable Solids: A practitioner's guide to theory, discretization and model reduction\"","link":"/2021/12/15/elastic-simulation/"},{"title":"linear solver","text":"Problem Solvers Jacobi/Gauss-Seidel iteration Conjugate gradients Reference Huamin Wang's GAMES103 course and Yuanming Hu's GAMES201 course","link":"/2021/12/13/linear-solver/"},{"title":"my FEM elastic simulation with Unity","text":"I finished Huamin Wang's GAMES103 homework 3. results: St. Venant Kirchhoff Model: Neo-Hookean Model + SVD (the 'principal stretches' or 'matrix invariants' method) A late Merry Christmas to myself ! ❄🎄🎅🔥😊 2021.12.26","link":"/2021/12/26/my-FEM-elastic-simulation-with-Unity/"},{"title":"rigid body collision","text":"Method: Shape Matching Basic Idea: first handle collision and friction of vertices independetnly, then enforce constraint to restore regidity. Advantages: Easy to implement and compatible with other nodal systems, i.e., cloth and soft bodies. Disadvantages: Difficult to strictly enforce friction and other goals. (The rigidification process will destroy them.) Suggestion: More suitable when the friction accuracy is less important, i.e., buttons on clothes. Reference Huamin Wang's GAMES103 course","link":"/2021/12/11/rigid-body-collision/"},{"title":"time integration","text":"common integration methods Forward Euler (explicit): Semi-implicit Euler (symplectic) Backward Euler (implicit) or Newton's method: (see one of the applications of this method here) comparison: explict vs. implict explict (forward Euler, symplectic Euler, RK, ... ) easy to implement, future only relies on past. 😟easy to explode: , especially for stiff materials. implicit (backward Euler, middle-point, ... ) future relies on past &amp; future, need to solve equations. support larger time step. 😟numerical damping &amp; locking. unifying CFL condition , where is CFL number, is time step, is length interval (e.g. particle radius, grid size), is maximum (velocity) Typical : SPH: MPM: FLIP fluid (smoke):","link":"/2021/12/13/time-integration/"}],"tags":[{"name":"Newton","slug":"Newton","link":"/tags/Newton/"},{"name":"gradient","slug":"gradient","link":"/tags/gradient/"},{"name":"iterative","slug":"iterative","link":"/tags/iterative/"},{"name":"tutorial","slug":"tutorial","link":"/tags/tutorial/"},{"name":"elastic","slug":"elastic","link":"/tags/elastic/"},{"name":"simulation","slug":"simulation","link":"/tags/simulation/"},{"name":"method","slug":"method","link":"/tags/method/"},{"name":"mpm","slug":"mpm","link":"/tags/mpm/"},{"name":"paper","slug":"paper","link":"/tags/paper/"},{"name":"2020","slug":"2020","link":"/tags/2020/"},{"name":"ECCV","slug":"ECCV","link":"/tags/ECCV/"},{"name":"rendering","slug":"rendering","link":"/tags/rendering/"},{"name":"neural","slug":"neural","link":"/tags/neural/"},{"name":"sum-up","slug":"sum-up","link":"/tags/sum-up/"},{"name":"cloth","slug":"cloth","link":"/tags/cloth/"},{"name":"PBD","slug":"PBD","link":"/tags/PBD/"},{"name":"Jacobi","slug":"Jacobi","link":"/tags/Jacobi/"},{"name":"Chebyshev","slug":"Chebyshev","link":"/tags/Chebyshev/"},{"name":"Gauss-Seidel","slug":"Gauss-Seidel","link":"/tags/Gauss-Seidel/"},{"name":"presentation","slug":"presentation","link":"/tags/presentation/"},{"name":"collision","slug":"collision","link":"/tags/collision/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"rigid","slug":"rigid","link":"/tags/rigid/"},{"name":"implicit","slug":"implicit","link":"/tags/implicit/"}],"categories":[]}